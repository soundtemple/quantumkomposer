//# QUANTUM KONTROLLER SUITE
//# KORDS APP
@OnLoad 
  ShowLayout 2
  LabelPads {[ QK:KORDS ]}
  SetShortName {KORDS}
	if unassigned scene_bank //# duration in first scene
		ResetNoteStates FALSE // #reset the locker with the value FALSE!
	  mode = 0 //# See @HandleModeChange for modes
	  songmode = 0 //# 0:Playsong 1:SceneLocked 2:ChordLocked
	  SetMetroPPQN 4
	  ppqn = 4 
		scene_change_requested = -1 //# on pad down has next scene number
	  chord_change_requested = -1 //# on pad down has next chord number
		chord_beat_count = -1
		scene_beat_count = -1
		scene_changed = FALSE
	  scene_change_chord_reset = TRUE //# Goto chord 0 when user changes scene
	  in_mode_select = FALSE //# Toggle for changing modes mode
	  number_of_modes = 16 //# Change in operational mode 
	  chords_out_octave = 2 //# base octave(3) for chords out (not harmony)
	  allow_mode_chg_playbk = TRUE //# Mode change during playback
	  return_to_song_mode_requested = FALSE //# used for switching on new bar 
	  rec_chord_note_count = 0 //# recording notes in chord slot
	  use_turn_around = TRUE //# last chord as turn around on last bar of scene
		allow_mel_harm_midi_ch_chg=FALSE //dangerous see sc_har1_slot see SendOutChordNotes
	  //# used for LED feedback
		last_pad=0 
		mgen_device_id=8 //used for midi control of pads. each mgen instance is assigned a number
		mgen_sel_dev=0 //used for midi control of pads
	  led_index=20 // notes 20-46 used for updating LED feedback on 16pads 
		midi_channel_conflict = FALSE //# allowing midi OUT channel conflicts
	  send_cc_back_to_knobs = TRUE
		knobs_controller=[15,40,41,42,43] //midi controller ch & 4 base ccs. cc's=cc's+(4xmgen_device_id
		txpose_w_circle_fifths=FALSE
		copy_mode=-1
	  Call @TransposeCalcArrays
	  Call @InitKnobVariables //# All knob settings on start
		Call @SysexMessageSetup
	  Call @SetupChordsScenes
	  Call @SetupKnobset0
	  Call @SetupLayout
	endif
@End

@SysexMessageSetup
	//QK Sysex messages. from KNTRL to BEATS and from BEATS to midi controllers
	qk_sysex_header=[0x3F,0x40,0x3F,0x40,0x3F,0x40] //QK messages
	len_header=6 
	//QK message types 
	sx_scene_change=100 //scene change
	sx_scene_durations=101 //scene durations
	sx_rtn_to_song=22 //return to song 
	sx_glbl_swing=23 //global swing
	sx_copy_scene=89 //Copy paste contents of whole scene
	sx_mgen_knobs=40 //MGEN 4 knobs --to knobs controller
@End

@InitKnobVariables
	//# Any knobset knob should have a setting here
	scn_duration = 0 
	scn_txpose = 0 
	scn_preset = 1
	scn_mel1_mode = 0
	scn_mel2_mode = 0
	scn_mel3_mode = 0 
	scn_mel4_mode = 0
	scn_out1_on = 1 //# 0 for off default ON
	scn_out2_on = 1
	scn_out3_on = 1
	scn_out4_on = 1
	num_sc_presets = 13
	num_mel_modes = 8 //# Harmonization rules for incoming midi
	//# modes: Off, ChordOnly, Round2Chord,  NonChord, Bass, Root, 3rd, 5th, Thru
	chrd_duration = 0
	chrd_inversion = 0
	chrd_bass = -1
	slct_chord_root = 0 //# Select chord mode only
  slct_chord_type = 0 //# Select chord mode only
  slct_chord_inversion = 0 //# Select chord mode only
	slct_chord_bass_note = -1 //# Select chord mode only
	
	//# Construct chords
	constructed_root = 0
	constructed_3rd = 2
	constructed_5th = 1
	constructed_7th = 3
	
	//# Midi channel options Mozaic uses 0-15 - we display 1-16
	//# Record Chords Ch [0]. MELODY A CH's [1-4]. HARMONY CH's' [5-8] for outgoing chords. 
	midi_channels_used = [4, 4,5,6,7, 8,9,10,11] //These need to stay fixed
	
	//# enable chords to be saved 
  FillArray sort_list, 0 //# empty array for sorting chord notes as arrive

  //# Selecting chords from types mode
  num_chord_types = 11 //# Chord types for select mode
  chord_types[0] = [4,7,-1] //# Major
  chord_types[5] = [3,7,-1] //# Minor
  chord_types[10] = [3,6,-1] //# Diminished
  chord_types[15] = [4,8,-1] //# Augmented
  chord_types[20] = [2,7,-1] //# Sus2
  chord_types[25] = [5,7,-1] //# Sus4
  chord_types[30] = [3,7,8] //# Minor 6th
  chord_types[35] = [4,7,9] //# Major 6th
  chord_types[40] = [3,7,10] //# Minor 7th
  chord_types[45] = [4,7,10] //# Dom 7th
  chord_types[50] = [4,7,11] //# Major 7th

	//# Intervals for constructing chords
	c3rd_intervals = [2, 3, 4, 5] //# sus2, min, maj, sus4
	c5th_intervals = [6, 7, 8] //# dim (b5), P5, aug (#5)
	c7th_intervals = [-1, 8, 9, 10, 11] //# min6 (b6), maj6, min7 (b7), maj7	
	
	//keeping track of held notes over chord changes
	//When a chrd chgs. Turn off all held notes and replace with notes of new chord
	update_held_notes_on_chord_change=TRUE
	held_chord_notes = [FALSE, FALSE, FALSE, FALSE] //
	held_chord_oct_adj = [0,0,0,0] 	
@End

@SetupChordsScenes
	current_scene = 0 // #0-7 Pads 0-7
  current_chord = 0 // #0-7 Pads 8-15
	num_scale_types = 4
  //# scene config: [duration, txpose, preset, mg1-4_modes, out_ch1-4 modes]
  //# MG Modes determine how harmonization occurs per scene
  sc_txp_slot = 1
  sc_preset_slot = 2
  sc_mel1_slot = 3 //# MELODY MODE slots in the scene bank
  sc_mel2_slot = 4
  sc_mel3_slot = 5
  sc_mel4_slot = 6
  sc_har1_slot = 7 //# HARMONY MODE slots in the scene bank
  sc_har2_slot = 8
  sc_har3_slot = 9
  sc_har4_slot = 10
  sc_size = 15 //# ^ above slots + duration = 11 + 4 spare for even sizing 
  rnd_scene_chg=FALSE //# will select rnd scene on (auto) change not user change
  
	//# chord = [note1, note2, note3, note4, duration, inv, bass, suggestion]
  dur_slot = 4 //# fixed location for duration
  inv_slot = 5
  bass_slot = 6
  sugg_slot = 7 //# for chord suggestion selected choice
 
  //# Create empty chord and scene arrays
  for s = 0 to 7 
	  //# Create 8 scene arrays in scene_bank
	  scene_bank[s*sc_size] = [0,6,1,1,1,1,1,8,8,8,8,-1]
		for c = 0 to 7
			//# Create 8 chord arrays for each scene
			chord_bank[(s*100) + (c*10)] = [-1, -1, -1, -1, 0, 0, -1, 0]
		endfor
	endfor
	
  //# indexing them by scene size (sc_size). Sample scenes
  //# eg scene2 ... scene_bank[sc_size * sc#(0-7)] = [2,6,0,0,0,0,0,1,1,1,1]
  scene_bank[0] = [1,6,1,1,1,1,1,8,8,8,8,-1]
	//# Example chords: increment in 10's in each scene, new scenes on the 100
  chord_bank[0] = [60, 64, 67, 71, 4, 0, 48] //# Scene1 Chord 1
  //# eg: chord_bank[10] = [67, 71, 74, 77, 8, 0, -1] //# Scene1 Chord 2
  //# eg: chord_bank[100] = [65, 69, 72, 76, 8, 0, -1] //# Scene2 Chord 1
  //# eg: chord_bank[110] = [69, 72, 76, 79, 4, 0, -1] //# Scene2 Chord 1
  
  //# Scale definitions for midi in key, scale handling
  //# Allowed scales for midi in
  allowed_scales = [1,2,3,4] 
  //# incoming midi key, scale. default C Major
	selected_midi_in_root = 0 // # root note -11 (C-B) Set in Knobset5
  selected_midi_in_scale = 0 // #see allowed_scales  
  midi_in_scales[10] = [0,2,4,5,7,9,11]  //# major
	midi_in_scales[20] = [0,2,3,5,7,8,10] // #minor_nat
	midi_in_scales[30] = [0,2,3,5,7,9,10]  // #minor_mel
	midi_in_scales[40] = [0,2,3,5,7,9,11]  // #minor_har
	Call @GetMidiInScale
	//# Setup Chord notes out - Options for how notes sent out
	cno_labels = [-1,0,1,3,5,7,15,135,1357,150,1350]
	cno_choices = 10 //# len(cno_labels) - 1
	cno_degrees[0] = [-1,-1,-1,-1]
	cno_degrees[4] = [0,-1,-1,-1]
	cno_degrees[8] = [1,-1,-1,-1]
	cno_degrees[12] = [3,-1,-1,-1]
	cno_degrees[16] = [5,-1,-1,-1]
	cno_degrees[20] = [7,-1,-1,-1]
	cno_degrees[24] = [1,5,-1,-1]
	cno_degrees[28] = [1,3,5,-1]
	cno_degrees[32] = [1,3,5,7]
	cno_degrees[36] = [0,1,5,-1]
	cno_degrees[40] = [0,1,3,5]
@End

@GetMidiInScale
	PresetScale allowed_scales[selected_midi_in_scale]
	SetRootNote selected_midi_in_root
	// #create an array with the notes of selected key scale
	scale_loc = allowed_scales[selected_midi_in_scale] * 10
	for scale_degree = 0 to 6
		// #ms is incoming_midi_scale
		midi_in_scale_notes[scale_degree] = (selected_midi_in_root + midi_in_scales[scale_loc + scale_degree]) % 12 
	endfor
	//Log {Passing notes: }, (NoteName midi_in_scale_notes[1]), { }, (NoteName midi_in_scale_notes[3]), { }, (NoteName midi_in_scale_notes[5])
	//Log {Play chord notes with: }, { }, (NoteName midi_in_scale_notes[0]), { }, (NoteName midi_in_scale_notes[2]), { }, (NoteName midi_in_scale_notes[4]), { }, (NoteName midi_in_scale_notes[6])
	//Log {Incoming melody scale: }, RootNoteName, { }, ScaleName
@End

@OnHostStart
	//# Start beat count on same beat as host
	//# In AUM getting HostBeat to start on 0 seems flaky
	//# Fixed by BramBos in June2020
	//Log HostBar, { : }, HostBeat, { = }, (HostBeatsPerMeasure * HostBar) + HostBeat
	if (HostBeat = 0) and (HostBar = 0)
		//# starting playback from beginning		
		chord_beat_count = -1
		scene_beat_count = -1
		scene_changed = FALSE
		if (songmode = 0)
			current_scene = 0
			current_chord = 0
		elseif (songmode = 1)
			current_chord = 0
		endif
		if mode > 2 
			//# No chord Rec, Select or Delete in playback
			mode = 0
		endif
	else
		//# continuing playback
		//# Could do nothing and allow continue with vars unchanged
		//# but in case use can jump timeline we are doing this to keep HostBeat aligned and chord/Scene at same relative positions.
		scene_completed_bars = scene_beat_count % HostBeatsPerMeasure
		chord_completed_bars = chord_beat_count % HostBeatsPerMeasure
		scene_beat_count = scene_completed_bars + HostBeat
		chord_beat_count = chord_completed_bars + HostBeat
	endif
	//Log {---- Host Started ----}
	Call @SetupLayout
@End

@OnHostStop
  Call @ResetBeatCounts
  //Log {---- Host Stopped ---- }, scene_beat_count, { - }, chord_beat_count 
  Call @SetupLayout
	for i = 5 to 8
		ch = midi_channels_used[i]
		Call @TurnOffChordNotes
	endfor
@End 

@ResetBeatCounts
	//# Re-start when mode or scene changes
	scene_beat_count = 0
	chord_beat_count = 0
	//# Log {Beat counts reset}
@End

@OnMetroPulse
@End

@OnNewBar
	//Log {--- new bar ---}
@End 

@OnNewBeat
	//Log {-- new beat --}
	//# increment beat counts xonb
	scene_beat_count = scene_beat_count + 1
	chord_beat_count = chord_beat_count + 1
	
	//# Handle Scene and Chord changes
	current_scene_duration = scene_bank[current_scene * sc_size]  * HostBeatsPerMeasure //# IN BEATS!
	chord_slot = (current_scene * 100) + ((current_chord) * 10)
	current_chord_duration = chord_bank[chord_slot + dur_slot]
	
	current_host_beat = (HostBar * HostBeatsPerMeasure) + HostBeat
	
	//# Log {Scene beats left: }, current_scene_duration - scene_beat_count
	//# Log {Chord beats left: }, current_chord_duration - chord_beat_count
  time_for_turnaround = FALSE
  if use_turn_around
  	Call @TimeForTurnaround
  endif
  
	//# Chord progressop -- Order of operations
	if (scene_change_requested > -1) and (HostBeat = 0)
		//# user requested scene change and its a new bar (& return to song)
		//# Log {Handling scene change request. It a new bar}
		Call @HandleSceneChange
	elseif (scene_beat_count >= current_scene_duration)
		//# its time to increment scene
		Call @HandleSceneChange
	elseif (chord_change_requested > -1)
  	//# User requested chord change & its a new beat
 		Call @HandleChordChange
 	elseif time_for_turnaround
 		Call @HandleChordChange
	elseif (chord_beat_count >= current_chord_duration) and (current_chord_duration>0) 
		Call @HandleChordChange
	endif
	if mode=0
		LabelPads {[ KORDS ]    Scene}, current_scene+1, {   Bar}, (Div scene_beat_count, HostBeatsPerMeasure)+1, {   Beat }, scene_beat_count+1, {/}, (current_scene_duration) 
	endif
@End

@TimeForTurnaround
	//# Under these conditions jump to last chord for 1 bar before scene change
	//# 2nd last chord in scene has no duration. Last chord has 4 beat duration
	//# Mode must be in song or scene lock
	//# must be 1 bar before scene ends
	//# Log {**** CHECKING TURN AROUND ****}
	chord6 = chord_bank[(current_scene * 100) + 60 + dur_slot]
	chord7 = chord_bank[(current_scene * 100) + 70 + dur_slot]
	//# Log {Chord6 dur: }, chord6, { Chord7 dur: }, chord7
	//# Log {SBC: }, scene_beat_count, { SC_DUR: }, current_scene_duration, { HBPM: }, HostBeatsPerMeasure
	//# Log scene_beat_count, { === }, (current_scene_duration - HostBeatsPerMeasure)
	if (songmode <= 1) and (chord6 = 0) and (chord7 = 4) and (current_chord <= 5) and (scene_beat_count = current_scene_duration - HostBeatsPerMeasure)
		time_for_turnaround = TRUE
		//Log {Its TURN AROUND TIME!!}
	endif
@End

@HandleSceneChange
	//# Work out which scene is next 
	scene_changed = TRUE
	if return_to_song_mode_requested
		return_to_song_mode_requested = FALSE
	endif
  if scene_change_requested > -1
  	current_scene = scene_change_requested
		scene_change_requested = -1
	elseif (songmode > 0)
  	current_scene = current_scene
  elseif (current_scene = 7) //# End of song 
    current_scene = 0 //# TODO: Handle end of song
  elseif scene_bank[(current_scene * sc_size) + sc_size] <= 0
  	//# also song end
  	current_scene = 0 //# no duration in next scene return to beginning
  else
		rnd_scene = Random 0,7 //# only move to rnd scene if it has a duration
    if rnd_scene_chg and scene_bank[rnd_scene*sc_size]>0
			current_scene = rnd_scene
		else
			current_scene = current_scene + 1 //# Going to next
		endif
  endif
  
  Call @ResetBeatCounts
  //Log {----- SCENE CHANGE -----}, {S}, current_scene+1
  Call @HandleChordChange //# Scene change effect chord change
@End

@HandleChordChange
	//# Work out what the next chord is 
	chord_slot = (current_scene * 100) + ((current_chord) * 10)
	if (chord_change_requested > -1)
		current_chord = chord_change_requested
		chord_change_requested = -1 //# reset request flag
		if songmode < 2
			songmode = 2 //# Lock to chord if user requests chord change
 		endif
 	elseif (scene_change_requested > -1) //# also handle chord change
		current_chord = 0
  	scene_change_requested = -1
  	scene_changed = FALSE
  elseif scene_changed
		//# reset chord to 0 on scene change if songmode < 2
		if (songmode <= 1)
			current_chord = 0
		endif
		scene_changed = FALSE
	elseif (songmode = 2) //# Loop current chord & Scene
    current_chord = current_chord
  elseif (current_chord = 7) //# Wrap playback
    current_chord = 0
  elseif (time_for_turnaround)
  	//# play last chord for one bar as a turn around before scene change
  	current_chord = 7
  elseif (chord_bank[(chord_slot+10) + dur_slot] <= 0)
  	current_chord = 0 //# no duration no next chord (chord_slot + 10)
  else
    current_chord = current_chord + 1
  endif
  chord_beat_count = 0 //# reset chord beat count on new chord
	
	if update_held_notes_on_chord_change
		for i = 5 to 8
			ch = midi_channels_used[i]
			Call @TurnOffChordNotes //turn off all chord notes on chord change & update notestate
		endfor
		for i = 0 to 3
			if held_chord_notes[i]
				ch=i+8
				trigger_note_oct_adj = held_chord_oct_adj[i]  //notes 48-59 no change
				Call @SendOutChordNotes //Send out new notes for held chord notes & update notestate
			endif
		endfor
	endif
	
  //# Label pads
  if not in_mode_select
	  LabelPads {[ KORDS ]  Scene: }, current_scene+1, { Chord: }, current_chord+1
  endif
  //Log {----- CHORD CHANGE -----}, {C}, current_chord+1
  Call @SetupLayout
@End

@LogCurrentInfo
	chord_slot = (current_scene * 100) + ((current_chord) * 10)
	current_chord_duration = chord_bank[chord_slot + dur_slot]
	current_scene_duration = scene_bank[current_scene * sc_size]
	Log {Playing: Scene: }, current_scene+1, { }, scene_beat_count+1, {/}, (current_scene_duration * HostBeatsPerMeasure), { beats}, { Chord:}, current_chord+1, { }, chord_beat_count+1, {/}, current_chord_duration, { beats}, { Mode: }, mode, { HostBeat: }, HostBeat+1
@End

@OnPadDown
  last_pad = LastPad // so midi in can simulate LastPad also see OnMidiIn
	Call @OnPadDown2 //midi input cant trigger @OnPadDown, It calls @OnPadDown2
@End

@OnPadDown2
	//# Splitting this event into separate handlers xopd
	if in_mode_select and (last_pad <= (number_of_modes - 1))
		if (HostRunning and (last_pad > 0) and NOT allow_mode_chg_playbk)
			Exit //# Only return to song allowed in playback
		elseif (last_pad=5 or last_pad=11 or last_pad=14)
			Exit //# Not in use
		elseif (HostRunning and last_pad=8)
			Exit //# Not allowed in playback
		elseif (last_pad = 1)
			in_mode_select = FALSE
			mode = 0
			knob_set = 1
			Call @SetupLayout
		elseif (last_pad = 7)
			Call @LogCurrentSceneToPresetFormat
		elseif (last_pad>=2 and last_pad<=4) //# +CHORDS MODES
			mode = last_pad-1 //# shifting mode to add kontroller slave in menu
			//Log {MODE:}, mode-1
			in_mode_select = FALSE
		elseif (last_pad>=8 and last_pad<=13)
    	//# midi setup modes - dont exit in_select_mode
    	mode = last_pad
			Call @SetupSettingsLayout
    elseif (HostRunning and last_pad=0)
    	//# Return to song mode requested
    	return_to_song_mode_requested = TRUE
    	scene_change_requested = current_scene
    	in_mode_select = FALSE
    	songmode = 0
    	mode = 0
    	ColorPad 0, 3
	    ColorPad 8, 3
			if mgen_device_id=mgen_sel_dev
				SendMIDINoteOn 15, 0+led_index, 3
				SendMIDINoteOn 15, 8+led_index, 3
			endif
		else
			mode = last_pad
			//Log {MODE:}, mode
			in_mode_select = FALSE
		endif
		Call @HandleModeChange
		Call @SetupLayout
		if (last_pad = 7)
			LabelPads {Scene preset data printed. Check log!}
		endif
	//# NOT IN MODE SELECT......
	elseif NOT in_mode_select
		//# handle mode actions if record or reset else do knob scene change
		if not (mode=15 or copy_mode=2)
			Call @OnPadDown_SceneChordChange //dont change if deleting or copy/pasting
		endif	
	 	Call @OnPadDown_KnobSetSelect
		if (mode = 3) and (last_pad > 7)
			Call @SetupLayout
	  	rec_chord_note_count = 0
  		LabelPad current_chord+8, {...waiting}
  		ColorPad current_chord+8, 1
			if mgen_device_id=mgen_sel_dev
				SendMIDINoteOn 15, current_chord+8+led_index, 1 //LED FEEDBACK
			endif
		elseif (mode = 6) //# COPY/PASTE
    	//# only call CP if pad and copy mode correspond
    	if copy_mode=0 and last_pad<=7
	    	Call @CopyPaste //# copy paste scene
	    elseif copy_mode=1 and last_pad>=8 
	    	Call @CopyPaste //# copy paste chord
	    endif
		elseif (mode = 15) and (last_pad <= 7) //# reset mode
    	//Log {Reset scene called}
    	Call @ResetScene   
 	 	elseif (mode = 15) and (last_pad >= 7)
    	//Log {Reset chord called}
    	Call @ResetChord
  	endif
  	if NOT HostRunning and (last_pad >= 8)
			for i = 5 to 8
				ch = midi_channels_used[i]
				trigger_note_oct_adj = 0 //pad down trigger uses default octave
	  		Call @SendOutChordNotes
			endfor
  	endif
	endif
@End

@OnPadUp
	last_pad=LastPad
  Call @OnPadUp2
@End

@OnPadUp2
	if NOT HostRunning and (last_pad >= 8)
		for i = 5 to 8
			ch = midi_channels_used[i]
  		Call @TurnOffChordNotes
		endfor
  endif
@End

@HandleModeChange
	//# Handle Labels
	if mode = 0
		LabelPads {[ KORDS ]  Scene: }, current_scene+1, { Chord: }, current_chord+1 
		Call @SetupKnobset1
		songmode = 0
	elseif mode = 1
		LabelPads {+CHORDS SELECT: Select chord, THEN set root, type, bass note}
		songmode = 2 //# Lock to chord
		Call @SetupKnobset2
	elseif mode = 2
		LabelPads {+CHORDS CONSTRUCT: Use knobs to build chord}
		songmode = 2 //# Lock to chord
		Call @SetupKnobset6
	elseif mode = 3
		LabelPads {+CHORDS RECORD: Select record channel, chord pad, then play chord notes}
		songmode = 2 //# Lock to chord
		Call @SetupKnobset1
	elseif mode = 6
		//# Copy/Paste pad hit so 'copy' current scene or chord
		//# in_select_mode = FALSE its already been exited
		if copy_mode=0 //# scene
			copied_scene = current_scene
			//Log {Copied current s}, current_scene+1
			LabelPads {Current scene copied. Select a scene to paste to}
		elseif copy_mode=1 //# chord
			copied_scene = current_scene //# just for labelling
			copied_chord = current_chord
			//Log {Copied current chord }, current_chord+1
			LabelPads {Current chord copied. Select a scene, then a chord slot to paste to}
		endif
	elseif mode = 8
		if NOT HostRunning
			LabelPads {MIDI INPUT Scale: Maps scale degrees IN to chord notes OUT}
			Call @SetupKnobset5
		endif
	elseif mode = 9
		LabelPads {MELODY MIDI CHANNELS: Notes transposed to current chord based on mode (per scene)}
		Call @SetupKnobset4
	elseif mode = 10
		LabelPads {MELODY MODES: 0.OFF 1.Chord, 2.RoundToChord, 3.+NonChord, 4.Bass, 5.Root, 6.Third, 7.Fifth 8.THRU}
		Call @SetupKnobset3
	elseif mode = 12
		LabelPads {HARMONY MIDI CHANNELS: Notes C-C#-D-D# (only) trigger chord note(s) out on channels 9-10-11-12 }
		Call @SetupKnobset7
	elseif mode = 13
		LabelPads {HARMONY MODES: Notes (C-C#-D-D#) determine channel. Mode determines chord note(s) sent}
		Call @SetupKnobset9
	elseif mode = 15
		LabelPads {DELETE: Select a scene or chord slot to reset}
	endif
	Call @SendMidiCCBackToKnobs
@End

@OnPadDown_SceneChordChange
	//# handle scene/chord change xopds
  if (last_pad >= 0 and last_pad <= 7)
  	//# Scene change
  	scene_change_requested = last_pad
		songmode=1 //locked to scene. User pressed scene pad
  	if NOT HostRunning //# immediate change else newbeat/bar handles
  		Call @HandleSceneChange 
  	endif
	elseif (last_pad >= 8 and last_pad <= 15) 	
  	//# User Chord change 
  	chord_change_requested = last_pad - 8 //# chrd 0-7
  	songmode=2 //lockt to chord. User pressed chord pad
		if NOT HostRunning //# immediate change else newbeat/bar handles
  		Call @HandleChordChange 
  	endif
  endif
	Call @SetupLayout	
@End

@OnPadDown_KnobSetSelect
	//# choose a knob set based on pad type
	if last_pad <= 7 and (NOT in_mode_select)
		if (mode = 1)	 //# Select quick chords 2 knobs
			Call @SetupKnobset2
		elseif (mode = 2) //# Construct chords 4 knobs
			Call @SetupKnobset6
		elseif (mode = 7)
			Call @SetupKnobset3 //# SCENE Midi IN Modes
		else
			Call @SetupKnobset0
		endif
	elseif last_pad >= 8 and NOT in_mode_select
		if (mode = 1)	
			Call @SetupKnobset2
		elseif (mode = 2) //# Construct chords 4 knobs
			Call @SetupKnobset6
		else
			Call @SetupKnobset1
		endif
	endif
	Call @SendMidiCCBackToKnobs
@End

@SendMidiCCBackToKnobs //# Update controller knob vals with midi cc
	//send LED feedback when mgen device is active device to mgen knobs
	if send_cc_back_to_knobs and mgen_device_id=mgen_sel_dev
		SendMidiCC knobs_controller[0], knobs_controller[1], (Round GetKnobValue 0)
		SendMidiCC knobs_controller[0], knobs_controller[2], (Round GetKnobValue 1), 25
		SendMidiCC knobs_controller[0], knobs_controller[3], (Round GetKnobValue 2), 50
		SendMidiCC knobs_controller[0], knobs_controller[4], (Round GetKnobValue 3), 75
	endif
@End

@OnAuParameter
  //Log {Last AU param: }, LastAUParameter
@End


@OnMidiCC
	//# Messages from KONTROLLER to update scene durs and play status for all instances in the KOMPOSER SUITE
	//Log {sending midi thru: }, MIDIChannel+1, {-}, MIDIByte2, {-}, MIDIByte3
	if MIDIChannel>=4 and MIDIChannel<=11 and MIDIByte2<=4
		SendMIDIThru // step cc automation from NOTES. Allowed ccs 0-4 only. 
	elseif (MIDIByte2>=101) and (MIDIByte2<=(101+7)) and (MIDIChannel=15) and MIDIByte3<=32
		//# handle scene duration change
		scene_bank[((MIDIByte2-101) * sc_size)] = MIDIByte3 
		Call @SetupLayout	
	elseif (MIDIByte2=22 and MIDIByte3>0 and MIDIChannel=15 and HostRunning)
  	return_to_song_mode_requested = TRUE //# handle return to song mode requested
  	in_mode_select = FALSE
		songmode = 0
  	mode = 0
		Call @SetupLayout
  	ColorPad current_scene, 6
    ColorPad 8, 3	
		if mgen_device_id=mgen_sel_dev
			SendMIDINoteOn 15, current_scene+led_index, 3
			SendMIDINoteOn 15, 8+led_index, 3
		endif
	elseif (MIDIByte2=22 and MIDIByte3>0 and MIDIChannel=15 and not HostRunning)
		return_to_song_mode_requested = TRUE
		in_mode_select = FALSE //Return to song mode
  	songmode = 0
  	mode = 0
		current_scene=0
		current_chord=0
		Call @SetupLayout
		ColorPad current_scene, 3
    ColorPad current_chord+8, 3
		if mgen_device_id=mgen_sel_dev
			SendMIDINoteOn 15, current_scene+led_index, 3
			SendMIDINoteOn 15, 8+led_index, 3
		endif
	elseif MIDIByte2>=40 and MIDIByte2<=43 //KNTRL Knobs on CH16
		if mgen_sel_dev=mgen_device_id
			last_knob = MIDIByte2-40 //simulate  LastPad action
			SetKnobValue last_knob, MIDIByte3 // change knob position
			Call @OnKnobChange2 //handle that change
		endif
	elseif (MIDIByte2=89 and MIDIChannel=15) //copy paste scene
		in_mode_select = FALSE // return to scenes mode first
  	mode = 0
		if MIDIByte3<=7 //handle copy scene
			copied_scene = MIDIByte3
			LabelPads {Scene }, MIDIByte3+1, { copied. Ready to paste}
		elseif MIDIByte3>=8 and MIDIByte3<=15 //handle scene paste
			LabelPads {Copied Scene }, copied_scene+1, { to Scene }, (MIDIByte3-8)+1
			CopyArray scene_bank[copied_scene * sc_size], scene_bank[(MIDIByte3-8) * sc_size], sc_size
			CopyArray chord_bank[copied_scene * 100], chord_bank[(MIDIByte3-8) * 100], 100
			songmode = 1
			mode=0
			copied_scene = -1 //# reset
			if in_mode_select
				Call @SetupSettingsLayout
			else
				Call @SetupLayout
			endif
		endif
	elseif MIDIByte2>=91 and MIDIByte2<=98 and MIDIByte3>0
		mgen_sel_dev=MIDIByte2-91+1 // range 1-9 to match display
		if mgen_sel_dev= mgen_device_id
			Call @OnShiftDown2 //will trigger layout setup for settings and other modes
		endif
	endif
@End

@OnSysex
  ReceiveSysex sysex_msg
  qk_msg=YES
  for i = 0 to len_header-1 //check header make sure its a QK sysex message
    if sysex_msg[i] <> qk_sysex_header[i]
      qk_msg=NO
    endif
  endfor
  if qk_msg 
    msg_start=len_header+1 //where msg_data starts
		msg_end=SysexSize-1 //where msg_data ends
		qk_msg_type=sysex_msg[len_header] //the message type received
		//handle msg types...
		if qk_msg_type = sx_scene_change
			//# handle scene change requested (ie: PadDown Scene change)
			if songmode=0 and HostRunning and sysex_msg[msg_start]=current_scene //in song mode. just lock to scene
				songmode=1 // lock to scene
			elseif songmode=0 and HostRunning
			  scene_change_requested = sysex_msg[msg_start]
				songmode=1
			elseif songmode=1 and HostRunning //locked to scene. re-trigger
				scene_change_requested = sysex_msg[msg_start]
				edit_scene=last_pad
			elseif NOT HostRunning //# immediate change else newbeat/bar handles
				scene_change_requested = sysex_msg[msg_start]
				songmode=1 // lock to scene
				Call @HandleSceneChange 
			endif
			Call @SetupLayout	
		endif
	endif
@End

@SaveSelectedChordPad
	//# save to pad in select mode once chord params chosen on knobs 
	//# chord to be updated
	chord_slot = (current_scene * 100) + ((current_chord) * 10)
	
	//# Set fields not updated here. Default if new else saved
	chrd_duration = 4 //# default value for new chord
	if chord_bank[chord_slot + dur_slot] > 0
		chrd_duration = chord_bank[chord_slot + dur_slot]
	endif
	chord_bank[chord_slot + dur_slot] = chrd_duration
	
	//# Only update changed fields
	if root_updated or type_updated
		//# Get chord_bank location and intervals for new chord
		chord_root = slct_chord_root
		chord_type_slot = slct_chord_type * 5 //# array saved in groups 5
		chord_3rd = (slct_chord_root + chord_types[chord_type_slot])
		chord_5th = (slct_chord_root + chord_types[chord_type_slot + 1])
		chord_7th = (slct_chord_root + chord_types[chord_type_slot + 2])
		//# A triad not a tetrad
		if chord_types[chord_type_slot + 2] = -1 
			chord_7th = -1
		endif
		//# update chord values in chord_bank
		chord_bank[chord_slot] = chord_root
		chord_bank[chord_slot + 1] = chord_3rd
		chord_bank[chord_slot + 2] = chord_5th
		chord_bank[chord_slot + 3] = chord_7th
		root_updated = FALSE
		type_updated = FALSE
	endif
	if inv_updated
		chrd_inversion = slct_chord_inversion	
		chord_bank[chord_slot + inv_slot] = chrd_inversion
		inv_updated = FALSE
	endif
	if bass_updated
		chrd_bass = slct_chord_bass_note
		chord_bank[chord_slot + bass_slot] =  chrd_bass
		bass_updated = FALSE
	endif	
	
	//# Update chord pads
	//Log {Chord notes }, chord_root, { }, chord_3rd, { }, chord_5th, { }, chord_7th, { 7th VAL: }, chord_bank[chord_slot + 3], { BASS VAL: }, chord_bank[chord_slot + bass_slot]
	chrd_to_label = current_chord+8
	Call @LabelChordPad
@End

@SaveConstructedChordPad
	//# save to pad in construct mode  			
	chord_slot = (current_scene * 100) + ((current_chord) * 10) //# chord to be updated
	
	//# Set fields not updated here. Default if new else saved
	chrd_duration = 4 //# default value for new chord
	if chord_bank[chord_slot + dur_slot] > 0
		chrd_duration = chord_bank[chord_slot + dur_slot]
	endif
	chord_bank[chord_slot + dur_slot] = chrd_duration
	
	chord_3rd = constructed_root + c3rd_intervals[constructed_3rd]
	chord_5th = constructed_root + c5th_intervals[constructed_5th]
	if constructed_7th > 0
		chord_7th = constructed_root + c7th_intervals[constructed_7th]
	else
		chord_7th = -1
	endif
	//# Save notes to chord slot
	chord_bank[chord_slot] = constructed_root
	chord_bank[chord_slot + 1] = chord_3rd
	chord_bank[chord_slot + 2] = chord_5th
	chord_bank[chord_slot + 3] = chord_7th
	chord_bank[chord_slot + bass_slot] = constructed_root

	//Log {Root: }, (NoteName constructed_root), { 3rd: }, c3rd_intervals[constructed_3rd], { 5th: }, c5th_intervals[constructed_5th], { 7th: }, c7th_intervals[constructed_7th], { Chord notes }, constructed_root, { }, chord_3rd, { }, chord_5th, { }, chord_7th, { 7th: }, chord_bank[chord_slot + 3], { BASS: }, chord_bank[chord_slot + bass_slot]
	chrd_to_label = current_chord+8
	Call @LabelChordPad
@End

@OnMidiNoteOn
	//# Process incoming midi to be re-harmonized (if not Rec Chords mode)
	//# Log {Midi received on CH: }, MIDIChannel, { note: }, MidiNote
	//# -1Off 0Chord 1Round 2+NonChord 3Bass 4Root 5Third 6Fifth 7thru
	//# Record chords from the channel set 
	if mode=3 and  MIDIChannel=midi_channels_used[0] // records mode 
		Call @HandleRecordNotes
	elseif MIDIChannel>=4 and MIDIChannel<=7 //MELODY Notes coming in
		for i = 1 to 4
			if MIDIChannel = midi_channels_used[i] and not (mode = 3)
				if i <= 4
					//# What is the scene harm. mode for this channel scene array slot 4-7
					sc_harm_mode = scene_bank[(current_scene * sc_size) + i + 2]
				else
					//# ch's 5-8 no mode select so default to 
					sc_harm_mode = 2 //# +NonChord = All Scale notes get harmonized
				endif
				//# Log {sc_harm_mode for harmony note is: }, sc_harm_mode, { Call CHN}
				//# Need to be able to call ConvertToHNotes to switch held notes 
				//# over chord change where there in no MidiNote
				midi_note = MidiNote
				midi_channel = MIDIChannel
				Call @ConvertToHarmonyNotes
				Exit
			endif
		endfor
	elseif MIDIChannel>=8 and MIDIChannel<=11 //HARMONY trigger/gate notes coming in  
		//can come on any channel 8-11 but C=>8 C#=>9 D=>10 D#=>11
		//so midi for all 4 harmony channels can come in on 1 midi channel
		if (MIDINote%12)<=3
			ch=(MIDINote%12)+8
			Call @TurnOffChordNotes // can only have one chord note per channel playing at any one time
			trigger_note_octave = Div MIDINote, 12 //note in influences octave out
			trigger_note_oct_adj = (trigger_note_octave - 4) * 12  //notes 48-59 no change
			Call @SendOutChordNotes
			if update_held_notes_on_chord_change //held note tracking for update on chord change
				held_chord_notes[ch-8] = TRUE
				held_chord_oct_adj[ch-8] = trigger_note_oct_adj
			endif
		endif
	elseif MIDIChannel=15 and MidiNote>=20 and MIDINote<=36 and mgen_sel_dev=mgen_device_id and mgen_device_id>=0 
		// notes 20-36 on channel 16  used to trigger MGEN pads 0-15
		if MIDINote=36 //SHIFT
			if MIDICommand=0x90 //noteOn	
				Call @OnShiftDown2
			endif
		else
			last_pad = MIDINote-20
			if MIDICommand=0x90 and MIDIByte3>0 //noteOn
				Call @OnPadDown2 //instead of OnPadDown which is only triggered by touch of GUI pads in Mosaic
			elseif MIDICommand=0x90 and MIDIByte3=0
				Call @OnPadUp2
			elseif MIDICommand=0x80 //Note off
			  Call @OnPadUp2
			endif
		endif
	endif
@End

@SendOutChordNotes
	//# Send out chord notes based on Midi OUT Channel settings
	//# Also send out chord notes if chord pad pressed when HostStopped
	//# Basically send out chord notes when a chord changes
	chord_slot = (current_scene * 100) + (current_chord * 10)
	
	//# Use a standardised octave for chord notes out
	//# First remove octave and then assign
	//# Add octave to avoid C=0 issues
	chord_root = chord_bank[chord_slot]
	chord_3rd = chord_bank[chord_slot + 1]
	chord_5th = chord_bank[chord_slot + 2]
	chord_7th = chord_bank[chord_slot + 3]
	chord_bass = chord_bank[chord_slot + bass_slot]
	chord_formed=FALSE
	if chord_root>=0 and chord_3rd>=0 and chord_5th>=0
		chord_formed=TRUE //# we dont want chord notes sent out before chord is formed
	endif
	//# Raw function uses this variable
	HAR_NOTE_OCTAVE = (chords_out_octave * 12) + 24  
	
	Call @MakeChordNotesRawOctave
	if chord_bass >= 0
		chord_bass = chord_bass % 12
		chord_bass = chord_bass + HAR_NOTE_OCTAVE - 12
	endif
	
	//# Handle inversion setting for chord notes out
	chrd_inversion = chord_bank[chord_slot + inv_slot]
	if (chrd_inversion <> 0)
		Call @HandleInversionSetting //# re-define chord notes to inverted order
	endif
	
	//# Handle scene transpose and trigger note octave adj
	txpose_index = scene_bank[(current_scene * sc_size) + sc_txp_slot]
	txpose_amt = txpose_array[txpose_index] //# scene txpose amount
	chord_root = chord_root + txpose_amt + trigger_note_oct_adj
	chord_3rd = chord_3rd + txpose_amt + trigger_note_oct_adj
	chord_5th = chord_5th + txpose_amt + trigger_note_oct_adj
	if chord_7th <> -1 //dont transpose the 7th if it's not ON
		chord_7th	= chord_7th + txpose_amt + trigger_note_oct_adj
	endif
	if chord_bass >= 0 //# -1 is off so dont txpose
		chord_bass = chord_bass + txpose_amt + trigger_note_oct_adj
	endif
	
	//# Get per scene Midi Out channel On/Off settings (ch=8-11 => slots 7-10)
	out_type = scene_bank[(current_scene * sc_size) + ch-1] //!!! relies on FIXED midi ch's see sc_har1_slot=7
	
	//# make a dummy scale to represent chord degrees saved in cno_degrees
	chord_scale = [chord_bass, chord_root, chord_root, chord_3rd, chord_3rd, chord_5th, chord_5th, chord_7th, chord_7th]
	for i = 0 to 3  //up to 4 notes can be sent in a mode
		ch_degree = cno_degrees[(4 * out_type) + i]
		Call @HumanizeVelocity
		//# send out chord notes
		if (ch_degree >=0) and chord_formed
			if chord_scale[ch_degree] > 0
				SendMIDINoteOn ch, chord_scale[ch_degree], velocity
				SetNoteState ch, i, chord_scale[ch_degree]
				// Log {Chord Note sent curr_chord}, current_chord, { note: }, chord_scale[ch_degree]
			endif
		endif
	endfor	
@End

@TurnOffChordNotes
	//# channels. requires a ch variable to be set before calling
	for i = 0 to 3
		//# stored in 1st 4 note slots (0-3) on each channel
		if (GetNoteState ch, i)
			SendMIDINoteOff ch, (GetNoteState ch, i), 127
	  	SetNoteState ch, i, FALSE
  	endif
  endfor
@End

@ConvertToHarmonyNotes
	//# Convert incoming midi note to a harmony note based on current chord
	//# Handles scene harmonization mode for the midi in channel also
	//# chord = [note1, note2, note3, note4, duration, inv, bass]
	//# scene = [duration, txpose, preset, mg_modes1-4]
	//# midi_in_scale_notes from selected_midi_in_root, selected_midi_in_key 
	//# [mis[0], mis[2], mis[4], mis[6]]  - chord notes
	//# [mis[1], mis[3], mis[5]] - passing notes
	//# Harm. modes: 
	//# - 0 Chord, 
	//# - 1 Round2chord, 
	//# - 2 Scene Scale, 
	//# - 3 Bass, 
	//# - 4 Root, 
	//# - 5 3rd, 
	//# - 6 5th
	chord_slot = (current_scene * 100) + (current_chord * 10)
	chord_root = chord_bank[chord_slot]
	chord_3rd = chord_bank[chord_slot+1] 
	chord_5th = chord_bank[chord_slot+2]
	chord_7th = chord_bank[chord_slot+3]
	chord_bass = chord_bank[chord_slot + bass_slot]
	
	//# Log {Converting Ch }, midi_channel, { - }, midi_note, { to Harmony}
	//# Log {Scene: }, current_scene, { Chord: }, chord_root, chord_3rd, chord_5th, chord_7th
	 
	//# Outgoing harmony note is what we are looking to get here
	incoming_scale_degree = 0
	HAR_NOTE_OUT = 0
	outgoing_note_canceled = FALSE //# if chord note = -1
	
	//# What is the scene harm. mode for this channel scene array slot 4-7
	//# sc_harm_mode is set in OnMidiNoteOn
	
	//# is the incoming note a chord note or a passing note
	Call @GetIncomingNoteType //# sets var incoming_scale_degree 
	
	//# Early checks to cancel outgoing.... sch_harm_modes..
	//# -1Off 0Chord 1Round 2+NonChord 3Bass 4Root 5Third 6Fifth 7thru
	if (chord_root = -1)
		outgoing_note_canceled = TRUE //# chord setup incomplete
	elseif (incoming_scale_degree >= 3) and (chord_3rd = -1)
		outgoing_note_canceled = TRUE //# chord setup incomplete
	elseif (incoming_scale_degree >= 5) and (chord_5th = -1)
		outgoing_note_canceled = TRUE //# chord setup incomplete
	elseif (incoming_scale_degree = 7) and (chord_7th = -1) and (sc_harm_mode <> 2)
		outgoing_note_canceled = TRUE //# triads dont play 7th notes  
		//# but in +NonChord we will play it like a non_scale note
		//# Log {Chord is triad. Incoming scale degree is 7th, so no output}
	elseif(sc_harm_mode = 3) and (chord_bass = -1)
		outgoing_note_canceled = TRUE //#No bass note for Bass only mode
		//Log {No bass note set for Bass only Harmonization mode}
	elseif (NOT incoming_scale_degree) and (sc_harm_mode <> 7 and sc_harm_mode <> 2)
		//Log {NOT A SCALE NOTE AND SCHARMode: }, sc_harm_mode
		outgoing_note_canceled = TRUE //# Not a scale note
	elseif (NOT incoming_is_chord_note) and (sc_harm_mode <> 1 and sc_harm_mode <> 2 and sc_harm_mode <> 7) 
		//# Only Round2chord, NonChord, & Thru modes can have passing notes 
		//Log {Not a chord note and mode: }, sc_harm_mode
		outgoing_note_canceled = TRUE
	elseif (sc_harm_mode = -1)
		outgoing_note_canceled = TRUE //# block notes mode
	endif

	if (NOT outgoing_note_canceled) and (sc_harm_mode <> 7) 
		//# Calc octave adj based on incoming octave and stored chord notes
		//# select chords saved? RootNote (0-11) + Intervals
		//# recorded chords saved as played and sorted. Any val
		octave_incoming_note = Div midi_note, 12
		chord_note_octave_adj = (octave_incoming_note - 3) * 12
		bass_note_octave_adj = (octave_incoming_note - 4) * 12
		if sc_harm_mode = 3
			HAR_NOTE_OCTAVE = bass_note_octave_adj + 36
		else
			HAR_NOTE_OCTAVE = chord_note_octave_adj + 36
		endif
		
		//# Remove octave but maintain ascending order
		Call @MakeChordNotesRawOctave
			
		//# Calculate a scn transpose amount
		txpose_index = scene_bank[(current_scene * sc_size) + sc_txp_slot]
		scn_txpose_amount = txpose_array[txpose_index]
	
		//# Handle single note harmony modes
		//# Positions based on root inversion, non-re-ordered chord notes
		if incoming_is_chord_note and sc_harm_mode = 3 //# Bass only
			//Log {CONVERT ALL TO BASS}
			HAR_NOTE_OUT = chord_bass
		elseif (incoming_is_chord_note and sc_harm_mode = 4) //# Root only
			//Log {CONVERT ALL TO ROOT}
			HAR_NOTE_OUT = chord_root
		elseif (incoming_is_chord_note and sc_harm_mode = 5) //# 3rd only
			//Log {CONVERT ALL TO 3RD}
			HAR_NOTE_OUT = chord_3rd
		elseif (incoming_is_chord_note and sc_harm_mode = 6) //# 5th only
			//Log {CONVERT ALL TO 5TH}
			HAR_NOTE_OUT = chord_5th
		endif
				
		//# Re-order harmony notes for inversions so we can still play the chord with CEGB and have C as lowest note. C will now become the lowest chord note post inversion
		//# Log {old chord root: }, chord_root
		chrd_inversion = chord_bank[chord_slot + inv_slot]
		if (chrd_inversion <> 0)
			//# re-define chord notes to inverted order
			Call @HandleInversionSetting
		endif
		//# Log {new chord root: }, chord_root
		
		//# handle chord, round to chord and scn_scale modes				
		if (sc_harm_mode = 0) or (sc_harm_mode = 1) or (sc_harm_mode = 2)
			//# Log { SCALE DEGREE: }, incoming_scale_degree
			if incoming_scale_degree = 1
				HAR_NOTE_OUT = chord_root
			elseif (incoming_scale_degree = 3)
				HAR_NOTE_OUT = chord_3rd
			elseif (incoming_scale_degree = 5)
				HAR_NOTE_OUT = chord_5th
			elseif (incoming_scale_degree = 7)
				HAR_NOTE_OUT = chord_7th
			elseif (incoming_scale_degree = 2) and (sc_harm_mode = 1)
				//# passing notes get converted to chord notes in round to chord mode
				HAR_NOTE_OUT = chord_root
			elseif (incoming_scale_degree = 4) and (sc_harm_mode = 1)
				//# passing notes get converted to chord notes in round to chord mode
				HAR_NOTE_OUT = chord_3rd
			elseif (incoming_scale_degree = 6) and (sc_harm_mode = 1)
				//# passing notes get converted to chord notes in round to chord mode
				HAR_NOTE_OUT = chord_5th 
			elseif (sc_harm_mode = 2) and (incoming_scale_degree = 2)
				//# eg: D(passing note) is +2st above C(chord root)
				HAR_NOTE_OUT = chord_root + 2 
			elseif (sc_harm_mode = 2) and (incoming_scale_degree = 4)
				//# eg: F(passing note) is +1st above E(chord third)
				HAR_NOTE_OUT = chord_3rd + 1 
			elseif (sc_harm_mode = 2) and (incoming_scale_degree = 6)
				//# eg: A(passing note) is +2st above G(chord 5th)
				HAR_NOTE_OUT = chord_5th + 2
			elseif (sc_harm_mode = 2) and (non_scale_note = 1)
				//# eg: C# is +1st above chord_root
				HAR_NOTE_OUT = chord_root + 1
			elseif (sc_harm_mode = 2) and (non_scale_note = 2)
				//# eg: D# is 1st below chord_third
				HAR_NOTE_OUT = chord_3rd - 1
			elseif (sc_harm_mode = 2) and (non_scale_note = 3)
				//# eg: F# is 1st below chord_5th
				HAR_NOTE_OUT = chord_5th - 1
			elseif (sc_harm_mode = 2) and (non_scale_note = 4)
				//# eg: G# is 1st above chord_5th
				HAR_NOTE_OUT = chord_5th + 1
			elseif (sc_harm_mode = 2) and (non_scale_note = 5)
				//# eg: A# is 1st below chord_7th
				HAR_NOTE_OUT = chord_5th + 3 //# in case 7th not assigned
			elseif (sc_harm_mode <> 2) and (incoming_scale_degree = 7) and (chord_7th = -1)
				//# rare case in +NonChord but the 7th chord note not assigned we allow but nee to make a note for this
				HAR_NOTE_OUT = chord_root - 1
			endif
		endif
		
		if (HAR_NOTE_OUT > 0) 		
			//# Apply octave adj + scn transpose calculated above
			HAR_NOTE_OUT = HAR_NOTE_OUT + scn_txpose_amount 
		
			//# save calculated harmony note to locker for note off recall
			SetNoteState MIDIChannel, midi_note, HAR_NOTE_OUT
			
			//# send note out
			Call @HumanizeVelocity
			if NOT incoming_is_chord_note
				velocity = velocity_dipped
			endif
	    SendMIDINoteOn MIDIChannel, HAR_NOTE_OUT, velocity  
			//Log {Melody note sent CH},MIDIChannel, { - }, HAR_NOTE_OUT, { HBEAT:}, HostBeat, { HBAR:}, HostBar
		endif
	elseif (sc_harm_mode = 7) 
		//# ignore scn_txpose and octave adj in thru mode
		SetNoteState MIDIChannel, midi_note, midi_note
		SendMIDINoteOn MIDIChannel, midi_note, MidiVelocity
		//# Log {Midi sent through in mode 8}
	endif
		 
@End

@GetIncomingNoteType
	//# midi_note set from MIDINote just before CHN is called
	incoming_note = midi_note % 12
	incoming_is_chord_note = FALSE
	non_scale_note = 0
	if incoming_note = midi_in_scale_notes[0]
		incoming_is_chord_note = TRUE
		incoming_scale_degree = 1
	elseif (incoming_note = midi_in_scale_notes[2])
	  incoming_is_chord_note = TRUE
	  incoming_scale_degree = 3
	elseif (incoming_note = midi_in_scale_notes[4])
		incoming_is_chord_note = TRUE
		incoming_scale_degree = 5
	elseif (incoming_note = midi_in_scale_notes[6])
	  incoming_is_chord_note = TRUE
		incoming_scale_degree = 7
	elseif (incoming_note = midi_in_scale_notes[1])
		incoming_is_chord_note = FALSE
		incoming_scale_degree = 2
	elseif (incoming_note = midi_in_scale_notes[3])
		incoming_is_chord_note = FALSE
		incoming_scale_degree = 4
	elseif (incoming_note = midi_in_scale_notes[5])
		incoming_is_chord_note = FALSE
		incoming_scale_degree = 6
	elseif (incoming_note = midi_in_scale_notes[0] + 1)
		non_scale_note = 1
	elseif (incoming_note = midi_in_scale_notes[2] - 1)
		non_scale_note = 2
	elseif (incoming_note = midi_in_scale_notes[4] - 1)
		non_scale_note = 3
	elseif (incoming_note = midi_in_scale_notes[4] + 1)
		non_scale_note = 4
	elseif (incoming_note = midi_in_scale_notes[6] - 1)
		non_scale_note = 5
	endif 
@End

@HandleInversionSetting
	//# Harmony notes get re-ordered by inversion, so that the 'root' is the lowest note of the chord (say E) but not the chort root (say C) in CEG 1st inv. 
	//# Log {Converting chord notes: }, chord_root, chord_3rd, chord_5th, chord_7th
	
	//# the current inversion
	chrd_inversion = chord_bank[chord_slot + inv_slot]
	
	//# add octave in case inverting down goes below zero
	hn1 = chord_root + 12
	hn2 = chord_3rd + 12
	hn3 = chord_5th + 12
	if chord_7th >= 0
		hn4 = chord_7th + 12
	else
		hn4 = chord_7th
	endif
		
	//# re-order for inversions
	//# Log {CHORD INVERSION = }, chrd_inversion
	if chrd_inversion = 1
		harmony_notes = [hn2, hn3, hn4, hn1+12]
		if chord_7th = -1
			harmony_notes = [hn2, hn3, hn1+12, hn4]
		endif
	endif
	if chrd_inversion = 2
		harmony_notes = [hn3, hn4, hn1+12, hn2+12]
		if chord_7th = -1
			harmony_notes = [hn3, hn1+12, hn2+12, hn4]
		endif
	endif
	if chrd_inversion = 3
		harmony_notes = [hn4, hn1+12, hn2+12, hn3+12]
		if chord_7th = -1
			harmony_notes = [hn1+12, hn2+12, hn3+12, hn4]
		endif
	endif
	if chrd_inversion = 4
		harmony_notes = [hn1+12, hn2+12, hn3+12, hn4+12]
		if chord_7th = -1
			harmony_notes = [hn1+12, hn2+12, hn3+12, hn4]
		endif
	endif
	if chrd_inversion = -1
		harmony_notes = [hn4-12, hn1, hn2, hn3]
		if chord_7th = -1
			harmony_notes = [hn3-12, hn1, hn2, hn4]
		endif
	endif
	if chrd_inversion = -2
		harmony_notes = [hn3-12, hn4-12, hn1, hn2]
		if chord_7th = -1
			harmony_notes = [hn2-12, hn3-12, hn1, hn4]
		endif
	endif
	if chrd_inversion = -3
		harmony_notes = [hn2-12, hn3-12, hn4-12, hn1]
		if chord_7th = -1
			harmony_notes = [hn1-12, hn2-12, hn3-12, hn4]
		endif
	endif
	if chrd_inversion = -4
		harmony_notes = [hn1-12, hn2-12, hn3-12, hn4-12]
		if chord_7th = -1
			harmony_notes = [hn1-12, hn2-12, hn3-12, hn4]
		endif
	endif
	//# Re-define chord notes based on inverted order
	//# remove octave added above
	chord_root = harmony_notes[0] - 12
	chord_3rd = harmony_notes[1] - 12
	chord_5th = harmony_notes[2] - 12
	if chord_7th >= 0
		chord_7th = harmony_notes[3] - 12
	endif
	//# Log {Converted harmony_notes: }, chord_root, chord_3rd, chord_5th, chord_7th
@End

@MakeChordNotesRawOctave
	//# Set variabes chord_root, 3rd, 5th and 7th.
	//# updated to remove octave but maintain ascending note order
	chord_root = chord_root % 12
	chord_3rd = chord_3rd % 12
	if chord_root > chord_3rd
		chord_3rd = chord_3rd + 12
	endif
	chord_5th = chord_5th % 12
	if chord_3rd > chord_5th
		chord_5th = chord_5th + 12
	endif
	if chord_7th >= 0
		chord_7th = chord_7th % 12
		if chord_5th > chord_7th
			chord_7th = chord_7th + 12
		endif
		chord_7th = chord_7th + HAR_NOTE_OCTAVE
	else
		chord_7th = -1
	endif
	chord_root = chord_root + HAR_NOTE_OCTAVE
	chord_3rd = chord_3rd + HAR_NOTE_OCTAVE
	chord_5th = chord_5th + HAR_NOTE_OCTAVE
	//# presets use actual note. chord select uses raw. so use % to cover
	chord_bass = chord_bass%12 + HAR_NOTE_OCTAVE 
@End
	
@HumanizeVelocity
	// #Velocity handling
  humanize_velocity = 80 // #50-100 Lower = more variation
  	dip_velocity_pct = 60 // #50-100 Reduce velocity by %
	humanize_pct = (Random humanize_velocity, 100 ) / 100
	inputVelocity = MidiVelocity
	if NOT MidiVelocity
		inputVelocity = 90
	endif
	velocity = RoundUp (inputVelocity * humanize_pct)
	velocity_dipped = RoundUp (velocity * dip_velocity_pct/100)
@End

@OnMidiNoteOff  
  // #handle midi notes for harmonizing note OFF
	if MIDIChannel>=4 and MIDIChannel<=7 //MELODY Notes OFF (chs5-8 display)  
		for i = 1 to 4
			if MIDIChannel = midi_channels_used[i] 
				// #retrieve the harmony_note sent from note locker
	    	harmony_note = GetNoteState MIDIChannel, MIDINote  
	    	SendMIDINoteOff MIDIChannel, harmony_note, MIDIVelocity  
	    	SetNoteState MIDIChannel, MIDINote, FALSE
				Exit	
			endif
		endfor
	elseif (MIDIChannel>=8 and MIDIChannel<=11) and (MIDINote%12 <= 3)  //HARMONY Notes off (chs9-12 display)	  
		ch=(MIDINote%12)+8
		Call @TurnOffChordNotes
		held_chord_notes[ch-8] = FALSE
		held_chord_oct_adj[ch-8] = 0
	elseif MIDIChannel=15 and MidiNote>=20 and MIDINote<=36 and mgen_sel_dev=mgen_device_id and mgen_device_id>=0 
		last_pad = MIDINote-20
		if (MIDICommand=0x90 and MIDIByte3=0) or MIDICommand=0x80 //Note off
			Call @OnPadUp2
		endif
	endif
@End

@HandleRecordNotes
	//Log {HANDLING RECORD NOTES TO CHORD SLOT}
	if (mode = 3) and (rec_chord_note_count <= 3)
  	//# In record mode and chord selected for updating
    //Log {Chord note recieved num: }, rec_chord_note_count
    
    if rec_chord_note_count = 0
	    //# Recording is happening so reset the current notes
	    chord_slot = (current_scene * 100) + (current_chord * 10)
	    for i = 0 to 3
	    	//Log {RESETTING CHORD SLOT }, chord_slot+i
  	  	chord_bank[chord_slot+i] = -1
    	endfor
    	chord_bank[chord_slot+inv_slot] = 0 //# start new chord with no inv.
    	rec_chord_notes = [-1,-1,-1,-1] //# reset array to empty
    	//Log {Current chord: }, current_chord
    	chrd_to_label = current_chord+8
    	Call @LabelChordPad //# re-label after notes reset
    endif
		
		//# Store recorded chord notes and update chord_bank and label
    rec_chord_notes[rec_chord_note_count] = MIDINote
    CopyArray rec_chord_notes, sort_list
    rec_chord_note_count = rec_chord_note_count + 1
    len_list = rec_chord_note_count
    if len_list > 1
	    Call @SortList
    endif
    CopyArray sort_list, rec_chord_notes
    Call @StoreChordNotes
    chrd_to_label = current_chord+8
    Call @LabelChordPad
    Call @SetupLayout
  endif
@End

@StoreChordNotes
	//# Store the recorded notes to the chord slot
  chord_slot = (current_scene * 100) + (current_chord * 10)
  for i = 0 to 3
  	if rec_chord_notes[i] >= 0
	  	chord_bank[chord_slot + i] = rec_chord_notes[i]
	  	//Log {Chord note }, i, { is }, rec_chord_notes[i], { in chord slot}, chord_slot+i
	  else
	  	chord_bank[chord_slot + i] = -1
	  endif
  endfor
	chord_bank[chord_slot + bass_slot] = chord_bank[chord_slot] //add a bass note on lowest note of chord
  if chord_bank[chord_slot + dur_slot] <= 0 //# Set a default duration
  	chord_bank[chord_slot + dur_slot] = 4
  endif
@End

@ResetScene
  //# Reset scene: Duration, Txpose, Preset, modes for ch's 1-4, out ch's ON1-4, pgm_chg_msg
  scene_bank[last_pad * sc_size] = [-1,6,0,0,0,0,0,0,0,0,0,-1]
  chord_slot = (last_pad * 100)
  for c = 0 to 7
		chord_bank[(current_scene*100) + (c*10)] = [-1, -1, -1, -1, 0, 0, -1]
	endfor
  Call @SetupLayout
  //Log {Scene }, last_pad +1, { reset. All chords for scene reset}
@End

@ResetChord
	chord_slot = (current_scene * 100) + ((last_pad - 8) * 10)
  //# 4 chord notes, duration, inv, bass, pattern_msg 
  chord_bank[chord_slot] = [-1,-1,-1,-1,0,0,-1,-1]
  //Log {Chord }, last_pad+1, { reset}
  Call @SetupLayout
@End

@CopyPaste
	//# copy paste scenes and chords xcp
	if last_pad <=7
		//Log {Pasting scene to }, current_scene+1 
		LabelPads {Copied Scene }, copied_scene+1, { to Scene }, last_pad+1
		CopyArray scene_bank[copied_scene * sc_size], scene_bank[last_pad * sc_size], sc_size
		CopyArray chord_bank[copied_scene * 100], chord_bank[last_pad * 100], 100
		//# Exit copy paste
		songmode = 1
		mode=0
	elseif last_pad >= 8
		//Log {pasting to chord }, last_pad-8
		LabelPads	{Copied S}, copied_scene+1, { Chord }, copied_chord+1, { to }, {S}, current_scene+1, { Chord }, last_pad-7
		chord_slot_from = (copied_scene * 100) + (copied_chord * 10)
		chord_slot_to = (current_scene * 100) + ((last_pad-8) * 10)
		CopyArray chord_bank[chord_slot_from], chord_bank[chord_slot_to], 10
		//# Exit copy paste
		songmode = 2
		mode=0
	endif
	copied_scene = -1 //# reset
	copied_chord = -1
	Call @SetupLayout 
@End

@SuggestChord
	//# Make a chord suggestion based on previous chord. Update current chord slot
	suggested_chord_notes=[]
	n1=0 //prev_root
	n2=4 //prev_3rd
	n3=7 //prev_5th
	n4=11 //prev_7th
	d=4 //duration
	i=0 //inversion
	if current_scene>0 and current_chord=0 //# use last chord prev_scene
		for i = 0 to 7
			test_slot = ((current_scene-1) * 100) + (i * 10)
			if chord_bank[chord_slot+dur_slot] > 0 //# chord has duration so use it	
					prev_chord_slot=test_slot
	  	endif
		endfor
		n1=chord_bank[prev_chord_slot]%12
		n2=chord_bank[prev_chord_slot+1]%12
		n3=chord_bank[prev_chord_slot+2]%12
		n4=chord_bank[prev_chord_slot+3]%12
		d=chord_bank[prev_chord_slot+4]%12
		i=chord_bank[prev_chord_slot+5]%12
	elseif current_chord>0
		prev_chord_slot = ((current_scene) * 100) + ((current_chord-1) * 10)
		n1=chord_bank[prev_chord_slot]%12
		n2=chord_bank[prev_chord_slot+1]%12
		n3=chord_bank[prev_chord_slot+2]%12
		n4=chord_bank[prev_chord_slot+3]%12
		d=chord_bank[prev_chord_slot+4]%12
		i=chord_bank[prev_chord_slot+5]%12
	endif
	
	//# chord = [note1, note2, note3, note4, duration, inv, bass]
	chord_suggest_bank[0*10]  = [n1,        n2,         n3,         n4,         d,i,n1]
	chord_suggest_bank[1*10]  = [n1,        (n1+2)%12,  n3,         -1,         d,i,n1] //sus2
	chord_suggest_bank[2*10]  = [n1,        (n1+3)%12,  n3,         -1,         d,i,n1] //minor
	chord_suggest_bank[3*10]  = [n1,        (n1+4)%12,  n3,         -1,         d,i,n1] //major
	chord_suggest_bank[4*10]  = [n1,        (n1+5)%12,  n3,         -1,         d,i,n1] //sus4
	chord_suggest_bank[5*10]  = [n1,        (n1+3)%12,  (n1+7)%12,  (n1+10)%12, d,i,n1] //minor7
	chord_suggest_bank[6*10]  = [n1,        (n1+4)%12,  (n1+7)%12,  (n1+11)%12, d,i,n1] //major7
	chord_suggest_bank[7*10]  = [n1,        (n1+4)%12,  (n1+7)%12,  (n1+10)%12, d,i,n1] //dom7
	chord_suggest_bank[8*10]  = [n2,        (n2+4)%12,  (n2+7)%12,  -1,         d,i,n2] //chords 3rd as root
	chord_suggest_bank[9*10]  = [n2,        (n2+3)%12,  (n2+7)%12,  -1,         d,i,n2]
	chord_suggest_bank[10*10] = [n2,        (n2+4)%12,  (n2+7)%12,  (n2+11)%12, d,i,n2]
	chord_suggest_bank[11*10] = [n2,        (n2+3)%12,  (n2+7)%12,  (n2+10)%12, d,i,n2]
	chord_suggest_bank[12*10] = [n3,        (n3+4)%12,  (n3+7)%12,  -1,         d,i,n3] //chords 5th as root
	chord_suggest_bank[13*10] = [n3,        (n3+3)%12,  (n3+7)%12,  -1,         d,i,n3]
	chord_suggest_bank[14*10] = [n3,        (n3+4)%12,  (n3+7)%12,  (n3+11)%12, d,i,n3]
	chord_suggest_bank[15*10] = [n3,        (n3+3)%12,  (n3+7)%12,  (n3+10)%12, d,i,n3]
	chord_suggest_bank[16*10] = [(n1+9)%12, (n1+12)%12, (n2+12)%12, -1,         d,i,(n1+9)%12] //chords root-3rd 
	
	//# Update the current chord with suggested notes
	chord_slot = (current_scene * 100) + (current_chord * 10) //# chord to update
	CopyArray chord_suggest_bank[chrd_sugg*10], chord_bank[chord_slot], 7
	chrd_to_label = current_chord+8
	Call @LabelChordPad
@End

@SetupKnobset0
	//# Scene settings
	knob_set = 0
	LabelKnobs {Scene }, current_scene+1, { setup}
	scn_duration = scene_bank[current_scene * sc_size]
	scn_txpose = scene_bank[(current_scene * sc_size) + sc_txp_slot]
	scn_preset = scene_bank[(current_scene * sc_size) + sc_preset_slot]
	LabelKnob 0, {Duration}
	LabelKnob 1, {Transpose}
	LabelKnob 2, {Preset }, scn_preset
	if txpose_w_circle_fifths
		LabelKnob 3, {TXP CoF} 
	else
		LabelKnob 3, {TXP ST}
	endif
	SetKnobValue 0, TranslateScale scn_duration, 0, 32, 0, 127
	SetKnobValue 1, TranslateScale scn_txpose, 0, 12, 0, 127
	SetKnobValue 2, TranslateScale scn_preset, 1, num_sc_presets, 0, 127
	SetKnobValue 3, TranslateScale txpose_w_circle_fifths, 0, 1, 0, 127 
@End
@KnobChangeSet0
	//# scene settings
	if last_knob = 0
	  scn_duration = Round TranslateScale (GetKnobValue 0), 0, 127, 0, 32
	  if scn_duration <> scene_bank[current_scene * sc_size] 	
		  scene_bank[current_scene * sc_size] = scn_duration
	  	LabelKnob 0 , {Dur }, scn_duration
	  endif
  endif
  if last_knob = 1
	  scn_txpose = Round TranslateScale (GetKnobValue 1), 0, 127, 0, 12
	  if scn_txpose <> scene_bank[(current_scene * sc_size) + sc_txp_slot] 	
		  scene_bank[(current_scene * sc_size) + sc_txp_slot] = scn_txpose
		  Call @SetupLayout //# re-label all chord pads
		endif
  endif
  if last_knob = 2
	  scn_preset = Round TranslateScale (GetKnobValue 2), 0, 127, 1, num_sc_presets
	  scene_bank[(current_scene * sc_size) + sc_preset_slot] = scn_preset
	  LabelKnob 2, scn_preset
  	Call @ChangeScenePreset
  endif
  if last_knob = 3
	  txpose_val = Round TranslateScale (GetKnobValue 3), 0, 127, 0, 1
		if txpose_val <> txpose_w_circle_fifths
			txpose_w_circle_fifths = txpose_val
			Call @TransposeCalcArrays
			Call @SetupLayout
			Call @SetupKnobset0
		endif
  endif
  scn_to_label = current_scene
  Call @LabelScenePad
@End

@SetupKnobset1
	//# Chord settings
	knob_set = 1
	LabelKnobs {Chord }, current_chord+1, { setup}
	chord_slot = (current_scene * 100) + ((current_chord) * 10)
	chrd_duration = chord_bank[chord_slot + dur_slot]
	chrd_inversion = chord_bank[chord_slot + inv_slot]
	chrd_bass = chord_bank[chord_slot + bass_slot]
	chrd_sugg = chord_bank[chord_slot + sugg_slot]
	if chrd_bass >= 0 //# leave -1 if not set
		chrd_bass = chord_bank[chord_slot + bass_slot] % 12
	endif
	if mode = 3
		LabelKnob 1, {REC CH }, midi_channels_used[0] + 1
		SetKnobValue 1, TranslateScale midi_channels_used[0], 4, 11, 0, 127
	else
		LabelKnob 1, {Suggest}, chrd_sugg
		SetKnobValue 1, TranslateScale chrd_sugg, 0, 16, 0, 127
	endif
	LabelKnob 0, {Duration}	
	LabelKnob 2, {Inv }, chrd_inversion
	if chrd_bass >= 0
		LabelKnob 3, {Bass }, (NoteName chrd_bass)
	else
		LabelKnob 3, {Bass }, {Off}
	endif
	SetKnobValue 0, TranslateScale chrd_duration, 0, 127, 0, 127
	SetKnobValue 2, TranslateScale chrd_inversion, -4, 4, 0, 127
	SetKnobValue 3, TranslateScale chrd_bass, -1, 11, 0, 127
@End
@KnobChangeSet1
//# chord settings
	chord_slot = (current_scene * 100) + ((current_chord) * 10)
	if last_knob = 0
	  chrd_duration = (Round TranslateScale (GetKnobValue 0), 0, 127, 0, 127)+1
	  if chrd_duration <> chord_bank[chord_slot + dur_slot] 
		  chord_bank[chord_slot + dur_slot] = chrd_duration
		  dur_bars = Div chrd_duration, 4
			dur_beats = (chrd_duration % HostBeatsPerMeasure) * (100/HostBeatsPerMeasure)
	  	LabelKnob 0 , {Dur }, dur_bars, {.}, dur_beats
  	endif
  endif
  if (mode = 3)
	  if last_knob = 1
		  midi_channels_used[0] = Round TranslateScale (GetKnobValue 1), 0, 127, 4, 11
			LabelKnob 1, {REC CH }, midi_channels_used[0] + 1
	  endif
	else
		if last_knob = 1
		  chrd_sugg = Round TranslateScale (GetKnobValue 1), 0, 127, 0, 16
			if chrd_sugg <> chord_bank[chord_slot + sugg_slot] 
		  	chord_bank[chord_slot + sugg_slot] = chrd_sugg
		  	LabelKnob 1, {Suggest}, chrd_sugg
	  		Call @SuggestChord
			endif
	  endif
  endif
  if last_knob = 2
	  chrd_inversion = Round TranslateScale (GetKnobValue 2), 0, 127, -4, 4
	  if chrd_inversion <> chord_bank[chord_slot + inv_slot] 
		  chord_bank[chord_slot + inv_slot] = chrd_inversion
		  LabelKnob 2, {Inv }, chrd_inversion
	  endif 
  endif
  if last_knob = 3
	  chrd_bass = Round TranslateScale (GetKnobValue 3), 0, 127, -1, 11
	 	if chrd_bass <> chord_bank[chord_slot + bass_slot] 
		  chord_bank[chord_slot + bass_slot] = chrd_bass
		  if chrd_bass >= 0
			  LabelKnob 3, {Bass }, (NoteName chrd_bass)
  		else
  			LabelKnob 3, {Bass }, {Off}
  		endif
  	endif
  endif
  //# Knob 1 not used in this set
  chrd_to_label = current_chord+8
  Call @LabelChordPad
@End

@SetupKnobset2
	//# Chord select settings
	knob_set = 2
	chord_slot = (current_scene * 100) + ((current_chord) * 10)
	LabelKnobs {Selecting }, {S}, current_scene+1, { Chord: }, current_chord+1
	
	//# if new chord default values from FillArray used here
	slct_chord_root = chord_bank[chord_slot] % 12
	slct_chord_inversion = chord_bank[chord_slot + inv_slot]
	slct_chord_bass_note = chord_bank[chord_slot + bass_slot] % 12
	
	//# Knob setup
	LabelKnob 0, {Root }, (NoteName slct_chord_root)
	LabelKnob 1, {Type}
	LabelKnob 2, {Inv }, slct_chord_inversion 
	LabelKnob 3, {Bass }, (NoteName slct_chord_bass_note)
	SetKnobValue 0, TranslateScale slct_chord_root, 0, 11, 0, 127
	SetKnobValue 1, TranslateScale slct_chord_type, 0, num_chord_types-1, 0, 127
	SetKnobValue 2, TranslateScale slct_chord_inversion, -4, 4, 0, 127
	SetKnobValue 3, TranslateScale slct_chord_bass_note, -1, 11, 0, 127
	//# prevent updating values not changed
	root_updated = FALSE
	type_updated = FALSE
	bass_updated = FALSE
	inv_updated = FALSE
@End
@KnobChangeSet2
	bass_updated = FALSE
	inv_updated = FALSE
	if last_knob = 0
	  slct_chord_root = Round TranslateScale (GetKnobValue 0), 0, 127, 0, 11
  	LabelKnob last_knob, {Root }, (NoteName slct_chord_root)
  	root_updated = TRUE
		bass_updated = TRUE
		slct_chord_bass_note = slct_chord_root
		LabelKnob 3, {Bass }, (NoteName slct_chord_bass_note)
  	Call @SaveSelectedChordPad
  elseif last_knob = 1
  	slct_chord_type = Round TranslateScale (GetKnobValue 1), 0, 127, 0, num_chord_types-1
  	if slct_chord_type = 0
  		LabelKnob 1, {Major}
  	elseif slct_chord_type = 1
  		LabelKnob 1, {Minor}
  	elseif slct_chord_type = 2
  		LabelKnob 1, {Diminished}
  	elseif slct_chord_type = 3
  		LabelKnob 1, {Augmented}
  	elseif slct_chord_type = 4
  		LabelKnob 1, {Sus2}
  	elseif slct_chord_type = 5
  		LabelKnob 1, {Sus4}
  	elseif slct_chord_type = 6
  		LabelKnob 1, {Minor 6th}
  	elseif slct_chord_type = 7
  		LabelKnob 1, {Major 6th}
  	elseif slct_chord_type = 8
  		LabelKnob 1, {Minor 7th}
  	elseif slct_chord_type = 9
  		LabelKnob 1, {Dom 7th}
  	elseif slct_chord_type = 10
  		LabelKnob 1, {Major 7th}
  	endif
  	type_updated = TRUE
  	Call @SaveSelectedChordPad
  elseif last_knob = 2
  	slct_chord_inversion = Round TranslateScale (GetKnobValue 2), 0, 127, -4, 4
	  LabelKnob last_knob, {Inv: }, slct_chord_inversion
	  inv_updated = TRUE
	  Call @SaveSelectedChordPad
  elseif last_knob = 3
	  slct_chord_bass_note = Round TranslateScale (GetKnobValue 3), 0, 127, -1, 11
  	LabelKnob last_knob, {Bass }, (NoteName slct_chord_bass_note)
  	bass_updated = TRUE
  	Call @SaveSelectedChordPad 
	endif
@End

@SetupKnobset3
	//# MELODY modes: Chord only, Round2chord,  NonChord, Bass, Root, 3rd, 5th
	knob_set = 3
	LabelKnobs {MELODY MODES S}, current_scene+1
	scn_mel1_mode = scene_bank[(current_scene * sc_size) + sc_mel1_slot]
	scn_mel2_mode = scene_bank[(current_scene * sc_size) + sc_mel2_slot]
	scn_mel3_mode = scene_bank[(current_scene * sc_size) + sc_mel3_slot]
	scn_mel4_mode = scene_bank[(current_scene * sc_size) + sc_mel4_slot]
	SetKnobValue 0, TranslateScale scn_mel1_mode, -1, num_mel_modes-1, 0, 127
	SetKnobValue 1, TranslateScale scn_mel2_mode, -1, num_mel_modes-1, 0, 127
	SetKnobValue 2, TranslateScale scn_mel3_mode, -1, num_mel_modes-1, 0, 127
	SetKnobValue 3, TranslateScale scn_mel4_mode, -1, num_mel_modes-1, 0, 127
	in1ch = midi_channels_used[1]
	in2ch = midi_channels_used[2]
	in3ch = midi_channels_used[3]
	in4ch = midi_channels_used[4]
	LabelKnob 0, {Ch}, in1ch, {: }, scn_mel1_mode+1
	LabelKnob 1, {Ch}, in2ch, {: }, scn_mel2_mode+1
	LabelKnob 2, {Ch}, in3ch, {: }, scn_mel3_mode+1
	LabelKnob 3, {Ch}, in4ch, {: }, scn_mel4_mode+1
	Call @LabelMelodyModesPad
	in1ch = midi_channels_used[1]
	in2ch = midi_channels_used[2]
	in3ch = midi_channels_used[3]
	in4ch = midi_channels_used[4]
	LabelKnob 0, {Ch}, in1ch+1, {: }, scn_mel1_mode+1
	LabelKnob 1, {Ch}, in2ch+1, {: }, scn_mel2_mode+1
	LabelKnob 2, {Ch}, in3ch+1, {: }, scn_mel3_mode+1
	LabelKnob 3, {Ch}, in4ch+1, {: }, scn_mel4_mode+1
@End
@KnobChangeSet3
	//# MELODY MODES settings
	//# Harmony modes: Chord only, Round to chord,  Scene Scale, Bass, Root, 3rd, 5th
	if last_knob = 0
	  scn_mel1_mode = Round TranslateScale (GetKnobValue 0), 0, 127, -1, num_mel_modes-1
	  scene_bank[(current_scene * sc_size) + sc_mel1_slot] = scn_mel1_mode
  endif
  if last_knob = 1
	  scn_mel2_mode = Round TranslateScale (GetKnobValue 1), 0, 127, -1, num_mel_modes-1
	  scene_bank[(current_scene * sc_size) + sc_mel2_slot] = scn_mel2_mode
  endif
  if last_knob = 2
	  scn_mel3_mode = Round TranslateScale (GetKnobValue 2), 0, 127, -1, num_mel_modes-1
	  scene_bank[(current_scene * sc_size) + sc_mel3_slot] = scn_mel3_mode
  endif
	if last_knob = 3
	  scn_mel4_mode = Round TranslateScale (GetKnobValue 3), 0, 127, -1, num_mel_modes-1
	  scene_bank[(current_scene * sc_size) + sc_mel4_slot] = scn_mel4_mode
  endif
  Call @LabelMelodyModesPad
  in1ch = midi_channels_used[1]
	in2ch = midi_channels_used[2]
	in3ch = midi_channels_used[3]
	in4ch = midi_channels_used[4]
	LabelKnob 0, {Ch}, in1ch+1, {: }, scn_mel1_mode+1
	LabelKnob 1, {Ch}, in2ch+1, {: }, scn_mel2_mode+1
	LabelKnob 2, {Ch}, in3ch+1, {: }, scn_mel3_mode+1
	LabelKnob 3, {Ch}, in4ch+1, {: }, scn_mel4_mode+1
@End
	
@SetupKnobset4
	//# MELODY CHANNELS
	knob_set = 4
	LabelKnobs {MELODY}
	for i=0 to 3
		SetKnobValue i, TranslateScale (midi_channels_used[i+1] - 4), -1, 3, 0, 127
	endfor
	Call @LabelKnobset4
	Call @LabelMelodyChannelsPad
@End
@LabelKnobset4
	//MELODY midi chs
	if midi_channels_used[1] = -1
	  LabelKnob 0, {Ch: }, {off}
	else
		LabelKnob 0, {Ch: }, midi_channels_used[1]+1  
	endif
	if midi_channels_used[2] = -1
	  LabelKnob 1, {Ch: }, {off}
	else
		LabelKnob 1, {Ch: }, midi_channels_used[2]+1  
	endif
	if midi_channels_used[3] = -1
	  LabelKnob 2, {Ch: }, {off}
	else
		LabelKnob 2, {Ch: }, midi_channels_used[3]+1  
	endif
	if midi_channels_used[4] = -1
	  LabelKnob 3, {Ch: }, {off}
	else
		LabelKnob 3, {Ch: }, midi_channels_used[4]+1  
	endif
@End
@KnobChangeSet4
	//# Midi in channels allowed 5-8 (store 4-9)
	if allow_mel_harm_midi_ch_chg
		sel_ch = (Round TranslateScale (GetKnobValue last_knob), 0, 127, -1, 3)
		if sel_ch>=0
			sel_ch=sel_ch+4
		endif
		midi_channels_used[last_knob+1] = sel_ch
	  Call @LabelMelodyChannelsPad
	  Call @LabelHarmonyChannelsPad
	  Call @LabelKnobset4
	endif
@End

@SetupKnobset5
	//# midi in key and scale
	knob_set = 5
	LabelKnobs {Midi IN scale}
	LabelKnob 0, {Key }, (NoteName selected_midi_in_root)
	LabelKnob 1, (ScaleName allowed_scales[selected_midi_in_scale])
	LabelKnob 2, { }
	LabelKnob 3, { }
	SetKnobValue 0, TranslateScale selected_midi_in_root, 0, 11, 0, 127
	SetKnobValue 1, TranslateScale selected_midi_in_scale, 0, num_scale_types-1, 0, 127
	SetKnobValue 2, 0
	SetKnobValue 3, 0
@End
@KnobChangeSet5
	//# Midi in scale
	if last_knob = 0
	  selected_midi_in_root = Round TranslateScale (GetKnobValue 0), 0, 127, 0, 11
	  LabelKnob last_knob, (NoteName selected_midi_in_root)
	  Call @GetMidiInScale
  endif
  if last_knob = 1
	  selected_midi_in_scale = Round TranslateScale (GetKnobValue 1), 0, 127, 0, num_scale_types-1
	  LabelKnob last_knob, (ScaleName allowed_scales[selected_midi_in_scale])
	  Call @GetMidiInScale
  endif
  LabelPad 8, {  MIDI INPUT  }, {   Key/Scale      }, (NoteName selected_midi_in_root), { }, (ScaleName allowed_scales[selected_midi_in_scale])
@End

@SetupKnobset6
	//# Chord construct settings
	knob_set = 6
	chord_slot = (current_scene * 100) + ((current_chord) * 10)
	LabelKnobs {Construct }, {S}, current_scene+1, { Chord: }, current_chord+1
	
	//# if new chord default values from FillArray used here
	constructed_root = chord_bank[chord_slot] % 12
	root_3rd_interval = chord_bank[chord_slot+1] - chord_bank[chord_slot]
	root_5th_interval = chord_bank[chord_slot+2] - chord_bank[chord_slot]
	root_7th_interval = chord_bank[chord_slot+3] - chord_bank[chord_slot]
	
	//# work out what knob value to assign knobs on selection on new chord pad
	if root_3rd_interval = 3
		constructed_3rd = 1
	elseif (root_3rd_interval = 4)
		constructed_3rd = 2
	elseif (root_3rd_interval > 4)
		constructed_3rd = 3
	else
		constructed_3rd = 0
	endif
	
	if root_5th_interval > 7
		constructed_5th = 2
	elseif (root_5th_interval < 7)
		constructed_5th = 0
	else
		constructed_5th = 1
	endif
	
	if root_7th_interval = 8
		constructed_7th = 1
	elseif (root_7th_interval = 9)
		constructed_7th = 2
	elseif (root_7th_interval = 10)
		constructed_7th = 3
	elseif (root_7th_interval = 11)
		constructed_7th = 4
	elseif (chord_bank[chord_slot+3] < 0)
		constructed_7th = 0
	else
		constructed_7th = 0
	endif
	
	//# Knob setup - Labelling
	LabelKnob 0, {Root }, (NoteName constructed_root)
	Call @LabelConstructed3rd
	Call @LabelConstructed5th
	Call @LabelConstructed7th
	
	SetKnobValue 0, TranslateScale constructed_root, 0, 11, 0, 127
	SetKnobValue 1, TranslateScale constructed_3rd, 0, 3, 0, 127
	SetKnobValue 2, TranslateScale constructed_5th, 0, 2, 0, 127
	SetKnobValue 3, TranslateScale constructed_7th, 0, 4, 0, 127
	//# prevent updating values not changed
	root_updated = FALSE
	3rd_updated = FALSE
	5th_updated = FALSE
	7th_updated = FALSE
@End
@KnobChangeSet6
	if last_knob = 0
	  constructed_root = Round TranslateScale (GetKnobValue 0), 0, 127, 0, 11
  	LabelKnob 0, {Root }, (NoteName constructed_root)
  	root_updated = TRUE
  elseif last_knob = 1
  	constructed_3rd = Round TranslateScale (GetKnobValue 1), 0, 127, 0, 3
  	Call @LabelConstructed3rd
  	3rd_updated = TRUE
  elseif last_knob = 2
  	constructed_5th = Round TranslateScale (GetKnobValue 2), 0, 127, 0, 2
	  Call @LabelConstructed5th 
	  5th_updated = TRUE
  elseif last_knob = 3
	  constructed_7th = Round TranslateScale (GetKnobValue 3), 0, 127, 0, 4
  	Call @LabelConstructed7th
  	7th_updated = TRUE 
	endif
	Call @SaveConstructedChordPad
@End
@LabelConstructed3rd
	if constructed_3rd = 0
		LabelKnob 1, {sus2}
	elseif constructed_3rd = 1
		LabelKnob 1, {min3 (b3)}
	elseif constructed_3rd = 2
		LabelKnob 1, {maj3}
	elseif constructed_3rd = 3
		LabelKnob 1, {sus4}
	endif
@End

@LabelConstructed5th
	if constructed_5th = 0
  	LabelKnob 2, {dim (b5)}
  elseif constructed_5th = 1
  	LabelKnob 2, {P5}
  elseif constructed_5th = 2
  	LabelKnob 2, {Aug (#5)}
  endif
@End

@LabelConstructed7th
	if constructed_7th = 0
  	LabelKnob 3, {None}
  elseif constructed_7th = 1
  	LabelKnob 3, {Min6 (b6)}
 	elseif constructed_7th = 2
  	LabelKnob 3, {Maj6}
  elseif constructed_7th = 3
 		LabelKnob 3, {Min7 (b7)}
 	elseif constructed_7th = 4
 		LabelKnob 3, {Maj7}
  endif
@End

@SetupKnobset7
	//# harmony channels
	knob_set = 7
	LabelKnobs {HARMONY CHS}
	for i = 0 to 3
		SetKnobValue i, TranslateScale (midi_channels_used[i+5]-8), -1, 3, 0, 127
	endfor
	Call @LabelKnobset7
	Call @LabelHarmonyChannelsPad
@End
@KnobChangeSet7
	//# harmony channels
	if allow_mel_harm_midi_ch_chg
		sel_ch = (Round TranslateScale (GetKnobValue last_knob), 0, 127, -1, 3)
		if sel_ch>=0
			sel_ch=sel_ch+8
		endif
		midi_channels_used[last_knob+5] = sel_ch
		Call @LabelMelodyChannelsPad
	  Call @LabelHarmonyChannelsPad
	  Call @LabelKnobset7
	endif
@End
@LabelKnobset7
	if midi_channels_used[5] = -1
	  LabelKnob 0, {Ch: }, {off}
	else
		LabelKnob 0, {Ch: }, midi_channels_used[5]+1
	endif
	if midi_channels_used[6] = -1
	  LabelKnob 1, {Ch: }, {off}
	else
		LabelKnob 1, {Ch: }, midi_channels_used[6]+1
	endif
	if midi_channels_used[7] = -1
	  LabelKnob 2, {Ch: }, {off}
	else
		LabelKnob 2,{Ch: }, midi_channels_used[7]+1
	endif
	if midi_channels_used[8] = -1
		LabelKnob 3, {Ch: }, {off}
	else
		LabelKnob 3, {Ch:}, midi_channels_used[8]+1
	endif
@End
	
@SetupKnobset8
	knob_set = 8
	LabelKnobs {UNUSED}
	SetKnobValue 0, 0
	SetKnobValue 1, 0
	SetKnobValue 2, 0
	SetKnobValue 3, 0
@End
@KnobChangeSet8
	//# Unused
@End

@SetupKnobset9
	//# Chord Notes out styles
	knob_set = 9
	LabelKnobs {HARMONY MODES S}, current_scene+1 
	kv1 = scene_bank[(current_scene * sc_size) + sc_har1_slot]
	kv2 = scene_bank[(current_scene * sc_size) + sc_har2_slot]
	kv3 = scene_bank[(current_scene * sc_size) + sc_har3_slot]
	kv4 = scene_bank[(current_scene * sc_size) + sc_har4_slot]
	SetKnobValue 0, TranslateScale kv1, 0, cno_choices, 0, 127
	SetKnobValue 1, TranslateScale kv2, 0, cno_choices, 0, 127
	SetKnobValue 2, TranslateScale kv3, 0, cno_choices, 0, 127
	SetKnobValue 3, TranslateScale kv4, 0, cno_choices, 0, 127
	Call @LabelKnobset9
	Call @LabelHarmonyModesPad
@End
@KnobChangeSet9
	//# Chord Notes Out style
	if last_knob = 0
	  scene_bank[(current_scene * sc_size) + sc_har1_slot] = Round TranslateScale (GetKnobValue 0), 0, 127, 0, cno_choices
  endif
  if last_knob = 1
	  scene_bank[(current_scene * sc_size) + sc_har2_slot] = Round TranslateScale (GetKnobValue 1), 0, 127, 0, cno_choices
	endif
  if last_knob = 2
	  scene_bank[(current_scene * sc_size) + sc_har3_slot] = Round TranslateScale (GetKnobValue 2), 0, 127, 0, cno_choices
  endif
  if last_knob = 3
	  scene_bank[(current_scene * sc_size) + sc_har4_slot] = Round TranslateScale (GetKnobValue 3), 0, 127, 0, cno_choices
  endif
  Call @LabelHarmonyModesPad
  Call @LabelKnobset9
@End
@LabelKnobset9
	kv1 = scene_bank[(current_scene * sc_size) + sc_har1_slot]
	kv2 = scene_bank[(current_scene * sc_size) + sc_har2_slot]
	kv3 = scene_bank[(current_scene * sc_size) + sc_har3_slot]
	kv4 = scene_bank[(current_scene * sc_size) + sc_har4_slot]
	chA = midi_channels_used[5]+1
	chB = midi_channels_used[6]+1
	chC = midi_channels_used[7]+1
	chD = midi_channels_used[8]+1
	if kv1 >= 2
		kv1_label = cno_labels[kv1]
		LabelKnob 0, {CH}, chA, { }, kv1_label
	elseif kv1 = 1
		LabelKnob 0, {CH}, chA, { Bass}
	else
		LabelKnob 0, {CH}, chA, { Off}
	endif
	
	if kv2 >= 2
		kv2_label = cno_labels[kv2]
		LabelKnob 1, {CH}, chB, { }, kv2_label
	elseif kv2 = 1
		LabelKnob 1, {CH}, chB, { Bass}
	else
		LabelKnob 1, {CH}, chB, { Off}
	endif
	
	if kv3 >= 2
		kv3_label = cno_labels[kv3]
		LabelKnob 2, {CH}, chC, { }, kv3_label
	elseif kv3 = 1
		LabelKnob 2, {CH}, chC, { Bass}
	else
		LabelKnob 2, {CH}, chC, { Off}
	endif
	
	if kv4 >= 2
		kv4_label = cno_labels[kv4]
		LabelKnob 3, {CH}, chD, { }, kv4_label
	elseif kv4 = 1
		LabelKnob 3, {CH}, chD, { Bass}
	else
		LabelKnob 3, {CH}, chD, { Off}
	endif
@End

@UpdateCurrentKnobset
	if knob_set = 0 
	  Call @SetupKnobset0 //# scene settings
  elseif knob_set = 1
  	Call @SetupKnobset1 //# chord settings
  elseif knob_set = 2
  	Call @SetupKnobset2	//# CHORD select
  elseif knob_set = 3
  	Call @SetupKnobset3	//# MELODY MODES
  elseif knob_set = 4
  	Call @SetupKnobset4	//# MELODY midi channels
  elseif knob_set = 5
  	Call @SetupKnobset5	//# midi in key scale
  elseif knob_set = 6
  	Call @SetupKnobset6	//# CHORD construct
  elseif knob_set = 7
  	Call @SetupKnobset7	//# HARMONY Midi channels
	elseif knob_set = 9
  	Call @SetupKnobset9	//# HARMONY MODES
  endif
	//# On entering select mode the following need knobsets selected
	if in_mode_select
		if (mode = 8)
			Call @SetupKnobset4
		elseif (mode = 9)
			Call @SetupKnobset5
		elseif (mode = 10)
			Call @SetupKnobset7
		elseif (mode = 12)
			Call @SetupKnobset9
		else
			//# disable knobs in_mode_select
			LabelKnobs { }
			SetKnobValue 0, TranslateScale mgen_device_id, 0, 9, 0, 127
			if mgen_device_id
				LabelKnob 0, {mgen# }, mgen_device_id
			else
				LabelKnob 0, {mgen# -}
			endif
			LabelKnob 1, { }
			LabelKnob 2, { }
			LabelKnob 3, { }
			knob_set = 99 //# dummy number to disable
		endif
	endif
	Call @SendMidiCCBackToKnobs
@End

@OnKnobChange
  last_knob=LastKnob
	Call @OnKnobChange2
@End

@OnKnobChange2
	if knob_set = 0 
	  Call @KnobChangeSet0 //# scene settings
  elseif knob_set = 1
  	Call @KnobChangeSet1 //# chord settings
  elseif knob_set = 2
  	Call @KnobChangeSet2	//# CHORD select
  elseif knob_set = 3
  	Call @KnobChangeSet3	//# MELODY modes
  elseif knob_set = 4
  	Call @KnobChangeSet4	//# MELODY midi channels
  elseif knob_set = 5
  	Call @KnobChangeSet5	//# midi in scale
  elseif knob_set = 6
  	Call @KnobChangeSet6	//# CHORD construct
  elseif knob_set = 7
  	Call @KnobChangeSet7	//# HARMONY channels
	elseif knob_set = 9
  	Call @KnobChangeSet9	//# HARMONY modes
	elseif knob_set = 99 //settings layout
    if last_knob = 0
		  val = Round TranslateScale (GetKnobValue 0), 0, 127, 0, 9
			if val <> mgen_device_id
				mgen_device_id=val
				if mgen_device_id
					LabelKnob 0, {mgen# }, mgen_device_id
				else
					LabelKnob 0, {mgen# -}
				endif
			endif
		endif
	endif 
@End 
		
@CheckMidiChannelConflict
	//# check for conflicts no recording channel list[0] or -1 settings
	midi_channel_conflict = FALSE
	for a = 1 to 8
		for b = 1 to 8
			if a <> b
				if (midi_channels_used[a] = midi_channels_used[b]) and (midi_channels_used[a] >= 0) and (a <= 8 or b <= 8)
						midi_channel_conflict = TRUE
				endif
			endif
		endfor
	endfor
@End

@LabelMelodyChannelsPad
	//# Call @CheckMidiChannelConflict -- turning off for now
	if NOT midi_channel_conflict
		LabelPad 9, {MELODY     }, { Midi chs }, midi_channels_used[1]+1, {-}, midi_channels_used[2]+1, {-}, midi_channels_used[3]+1, {-}, midi_channels_used[4]+1
	else
		LabelPad 9, {MELODY    }, {!CONFLICT! }, midi_channels_used[1]+1, {-}, midi_channels_used[2]+1, {-}, midi_channels_used[3]+1, {-}, midi_channels_used[4]+1
	endif
@End

@LabelMelodyModesPad
	if in_mode_select
		scm1 = scene_bank[(current_scene * sc_size) + sc_mel1_slot] + 1
		scm2 = scene_bank[(current_scene * sc_size) + sc_mel2_slot] + 1
		scm3 = scene_bank[(current_scene * sc_size) + sc_mel3_slot] + 1
		scm4 = scene_bank[(current_scene * sc_size) + sc_mel4_slot] + 1
		LabelPad 10, {MELODY Modes }, { S}, current_scene+1, {      }, scm1, {-}, scm2, {-}, scm3, {-}, scm4
	endif
@End

@LabelHarmonyChannelsPad
	//# Call @CheckMidiChannelConflict -- turning off for now
	if NOT midi_channel_conflict
		LabelPad 12, {HARMONY   }, { Midi chs   }, midi_channels_used[5]+1, {-}, midi_channels_used[6]+1, {-}, midi_channels_used[7]+1, {-}, midi_channels_used[8]+1
	else
		LabelPad 12, {HARMONY   }, {  !CONFLICT!  }, midi_channels_used[5]+1, {-}, midi_channels_used[6]+1, {-}, midi_channels_used[7]+1, {-}, midi_channels_used[8]+1
	endif
@End

@LabelHarmonyModesPad
	o1 = scene_bank[(current_scene * sc_size) + sc_har1_slot]
	o2 = scene_bank[(current_scene * sc_size) + sc_har2_slot]
	o3 = scene_bank[(current_scene * sc_size) + sc_har3_slot]
	o4 = scene_bank[(current_scene * sc_size) + sc_har4_slot]
	LabelPad 13, {HARMONY Modes }, {S}, current_scene+1, {     }, o1, {-}, o2, {-}, o3, {-}, o4
@End

@OnShiftDown
  Call @OnShiftDown2 //simply to allow midi note in simulation of SHIFT Note16 any channel
@End	

@OnShiftDown2
	if in_mode_select
		in_mode_select = FALSE
		LabelPads {[ KORDS ]  Scene: }, current_scene+1, { Chord: }, current_chord+1
		if (mode >= 1)
			mode = 0
			knob_set = 1
		endif		
		Call @SetupLayout
	else
		Call @SetupSettingsLayout
	endif
@End

@SetupSettingsLayout
// #Mode selection for Knobs n Pads
		in_mode_select = TRUE
		LabelPads {_QK:KORDS SETTINGS:   (shift to exit)}
		for i = 0 to (number_of_modes - 1)
			ColorPad i, 6
			LabelPad i, { } //# empty label to overwrite chord info
			LatchPad i, NO 
		endfor
		settings_pad_cols=[8,4,7,7,7,0,4,3, 2,4,4,0,3,3,0,1]
		if (songmode = 0)
			LabelPad 0, {PLAYSONG: Active }
		elseif (songmode = 1)
			LabelPad 0, {PLAYSONG: Scene locked}
		elseif (songmode = 2)
			LabelPad 0, {PLAYSONG: Chord locked}
		else
			LabelPad 0, {PLAYSONG: Disabled}
		endif	
		LabelPad 1, {SCENES}
		LabelPad 2, {+CHORDS: Select}
		LabelPad 3, {+CHORDS: Construct}
		LabelPad 4, {+CHORDS: Record}
		LabelPad 5,{ }
		if last_pad<=7 //# copy scene or chord
			LabelPad 6, {COPY/PASTE }, {SCENE }, current_scene+1
			copy_mode=0
		else
			LabelPad 6, {COPY/PASTE }, {CHORD }, current_chord+1
			copy_mode=1 
		endif
		LabelPad 7, { SAVE     }
		LabelPad 8, { MIDI INPUT  }, {   Key/Scale      }, (NoteName selected_midi_in_root), { }, (ScaleName allowed_scales[selected_midi_in_scale])
		Call @LabelMelodyChannelsPad //pad8
		Call @LabelMelodyModesPad		//pad9
		LabelPad 11,{ }
		Call @LabelHarmonyChannelsPad //pad11
		Call @LabelHarmonyModesPad //pad12
		LabelPad 14,{ }
		LabelPad 15, {DELETE  }
		if (mode>=1 and mode<=3)
			LatchPad mode+1, YES //#shifted +Chords in menu
			settings_pad_cols[mode+1]=8
		else
			LatchPad mode, YES
			settings_pad_cols[mode]=8
		endif
		for i = 0 to (number_of_modes - 1)
			ColorPad i, settings_pad_cols[i]
			if mgen_device_id=mgen_sel_dev
				SendMIDINoteOn 15, i+led_index, settings_pad_cols[i]
			endif
			if settings_pad_cols[i]=8
				LatchPad i, YES
			endif
		endfor
	Call @UpdateCurrentKnobset
@End

@SortList
  //# set list to sort to sort_list and len_list to # items is your list
  //Log {List to sort }, sort_list[0], sort_list[1], sort_list[2], sort_list[3]
  changed = 1
  while (changed = 1)
    changed = 0
    for i = 0 to len_list - 2
	  if sort_list[i] > sort_list[i+1]
	     changed = 1
        tmp = sort_list[i]
        sort_list[i] = sort_list[i+1]
        sort_list[i+1] = tmp
      endif
    endfor
  endwhile
  //Log {Sorted List: }, sort_list[0], sort_list[1], sort_list[2], sort_list[3]
@End

@LabelScenePad
	//# Set scn_to_label var before calling
	sc_dur = scene_bank[scn_to_label * sc_size]
	sc_txp = txpose_labels[scene_bank[(scn_to_label * sc_size) + sc_txp_slot]]
	sc_preset = scene_bank[(scn_to_label * sc_size) + sc_preset_slot]
	sc_txpm = sc_txp - 3
	if sc_txpm < 0
		sc_txpm = sc_txpm + 12
	endif
	if txpose_w_circle_fifths
		LabelPad scn_to_label, {S}, scn_to_label+1, { [}, sc_dur, { bars]}, {    }, (NoteName sc_txp), {/}, (NoteName sc_txpm), {m(}, txpose_array[scene_bank[(scn_to_label * sc_size) + sc_txp_slot]], {st) }
	else
		LabelPad scn_to_label, {S}, scn_to_label+1, { [}, sc_dur, { bars]}, {    Txpose: }, txpose_array[scene_bank[(scn_to_label * sc_size) + sc_txp_slot]], {st }
	endif
@End

@LabelChordPad
	//# Set chrd_to_label var before calling xlcp
	chord_slot = (current_scene * 100) + ((chrd_to_label-8) * 10)
	//# txpose amount. get value stored on dial use to access array of st amounts
	txpose_index = scene_bank[(current_scene * sc_size) + sc_txp_slot]
	sta = txpose_array[txpose_index] //# scene txpose amount
	cn1 = (chord_bank[chord_slot] + 12 + sta) % 12
	cn2 = (chord_bank[chord_slot + 1] + 12 + sta) % 12
	cn3 = (chord_bank[chord_slot + 2] + 12 + sta) % 12
	if chord_bank[chord_slot + 3] >= 0
		cn4 = (chord_bank[chord_slot + 3] + 12 + sta) % 12
	else
		cn4 = chord_bank[chord_slot + 3] // ie -1 no 7th note
	endif
	cd = chord_bank[chord_slot + dur_slot]
	cd_bars = Div cd, 4
	lc_beats = (cd % HostBeatsPerMeasure) * (100/HostBeatsPerMeasure)
	ci = chord_bank[chord_slot + inv_slot]
	if chord_bank[chord_slot + bass_slot] >= 0
		cb = (chord_bank[chord_slot + bass_slot] + 12 + sta) % 12
	else
		cb = chord_bank[chord_slot + bass_slot] //# ie -1
	endif
	
	Call @ReorderNoteLabelsForInversion
	if cn4 >= 0 //# A tetrad witha a note i cn4 
		LabelPad chrd_to_label, {[}, cd_bars, {.}, lc_beats, { bars]}, { Inv:}, 	ci, {     Root:}, (NoteName cn1), {     Bass:}, (NoteName cb), {      }, (NoteName invo[0]), (NoteName invo[1]), (NoteName invo[2]), (NoteName invo[3])  
	else
		LabelPad chrd_to_label, {[}, cd_bars, {.}, lc_beats, { bars]}, { Inv:}, 	ci, {     Root:}, (NoteName cn1), {     Bass:}, (NoteName cb), {      }, (NoteName invo[0]), (NoteName invo[1]), (NoteName invo[2])
	endif
@End

@ReorderNoteLabelsForInversion
	//# Just re-orders the notes on the chord pad in inverted order
	invo = [] //# inverted chord notes
	if (ci = 0) or (ci = 4) or (ci = -4)
		invo = [cn1, cn2, cn3, cn4]
	elseif ci = 1
		invo = [cn2, cn3, cn4, cn1]
		if cn4 = -1
			invo = [cn2, cn3, cn1, cn4]
		endif
	elseif ci = 2
		invo = [cn3, cn4, cn1, cn2]
		if cn4 = -1
			invo = [cn3, cn1, cn2, cn4]
		endif
	elseif ci = 3
		invo = [cn4, cn1, cn2, cn3]
		if cn4 = -1
			invo = [cn1, cn2, cn3, cn4]
		endif
	elseif ci = -1
		invo = [cn4, cn1, cn2, cn3]
		if cn4 = -1
			invo = [cn3, cn1, cn2, cn4]
		endif
	elseif ci = -2
		invo = [cn3, cn4, cn1, cn2]
		if cn4 = -1
			invo = [cn2, cn3, cn1, cn4]
		endif
	elseif ci = -3
		invo = [cn2, cn3, cn4, cn1]
		if cn4 = -1
			invo = [cn1, cn2, cn3, cn4]
		endif
	endif
@End

@SetupLayout
	//#xsl setup layout pads
  if in_mode_select
  	Exit
  else
		//# Setup scene pads
		FillArray scn_pad_cols, 0, 16
		for i = 0 to 7  
	    if scene_bank[i * sc_size] > 0
				scn_pad_cols[i]=2
				scn_to_label = i
				Call @LabelScenePad
	  	else
				scn_pad_cols[i]=0
	  		LabelPad i, { }
	  	endif
	    LatchPad i, NO
	    if (scene_bank[i * sc_size] > 0) and (mode = 15) and NOT in_mode_select
				scn_pad_cols[i]=1
	    endif
	  endfor		  
	  //# Setup chord pads  
    for i = 8 to 15
	    chord_slot = (current_scene * 100) + ((i-8) * 10)
	    LatchPad i, NO
	    if chord_bank[chord_slot + dur_slot] > 0
				scn_pad_cols[i]=2
	    	chrd_to_label = i
	    	Call @LabelChordPad
	    else 
				scn_pad_cols[i]=0
	  		LabelPad i, { }
	  	endif
	    if (mode = 3) //del
				scn_pad_cols[i]=1
		  elseif (mode = 15) and (chord_bank[chord_slot] >= 0)
				scn_pad_cols[i]=1
		  endif
	  endfor
		//# Handle current scene and chord colors
	  if (songmode = 0) //# Playthru no lock
	  	scn_pad_cols[current_scene]=3
	  	scn_pad_cols[current_chord+8]=3
	  elseif (songmode = 1) //# Lock to scene
	    scn_pad_cols[current_chord+8]=3
			scn_pad_cols[current_scene]=4
	  elseif (songmode = 2)
	    scn_pad_cols[current_chord+8]=4
			scn_pad_cols[current_scene]=4
	  elseif (mode = 3) //# REC CHORDS 
			scn_pad_cols[current_chord+8]=1
			if rec_chord_note_count = 0
				LabelPad current_chord+8, {... waiting}
			endif
		endif
		//# Handle pending chord and scene changes in playback
	  if HostRunning and (songmode <=2)
	  	if chord_change_requested >= 0
				scn_pad_cols[chord_change_requested+8]=6
	  	endif
	  	if scene_change_requested >= 0
	  		scn_pad_cols[scene_change_requested]=6
	  	endif
		endif
	endif
	for i = 0 to 15
		ColorPad i, scn_pad_cols[i]
		if mgen_device_id=mgen_sel_dev
			SendMIDINoteOn 15, i+led_index, scn_pad_cols[i]
		endif
	endfor
@End
	
@TransposeCalcArrays
	if txpose_w_circle_fifths
	  //# Creates an array to transpose using the circle of 5ths 
	  //# but keeping to one octave
	  FillArray txpose_array, 99, 13
	  FillArray txpose_labels, 99, 13 
	  txpose_index = 0
	  for i = 6 to 11
	    key = (i * 7) % 12
	    txpose_val = key
	    if key > Abs (key - 12)
	      txpose_val = key - 12 
	    endif
	    // Log {APos: }, i, { Key: }, (NoteName key), { TXPOSE: }, txpose_val, { Semitones: }, key, { -VE: }, key -12
	    txpose_array[txpose_index] = txpose_val
	    label = txpose_array[txpose_index]
	    if txpose_array[txpose_index] < 0
	      label = txpose_array[txpose_index] + 12
	    endif
	    txpose_labels[txpose_index] = label
	    txpose_index = txpose_index + 1 
	  endfor  
	  for i = 0 to 6
	    key = (i * 7) % 12
	    txpose_val = key
	    if key > Abs (key - 12)
	      txpose_val = key - 12 
	    endif
	    // Log {BPos: }, i, { Key: }, (NoteName key), { TXPOSE: }, txpose_val, { Semitones: }, key, { -VE: }, key -12 
	    txpose_array[txpose_index] = txpose_val
	    label = txpose_array[txpose_index]
	    if txpose_array[txpose_index] < 0
	      label = txpose_array[txpose_index] + 12
	    endif
	    txpose_labels[txpose_index] = label
	    txpose_index = txpose_index + 1
	  endfor
	else
		txpose_array = [-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6]
	endif
@End

@ChangeScenePreset
	//# Update chords for the current scene with a set of chords
	//# Create a scene in scene_bank
	//# use arrays psd, psn, prog_durs, prog_invs, prog_bass to load data 
	//# use psn array for scale notes, use 0 in front to keep numbering sane
	//# use 1 octave of scale notes. Inversions will be calculated
	//# Call @HandleChordBankPresetUpdate and then LabelPads with scene name
	//# ionian = [2,2,1,2,2,2,1] CDEFGABC [0, 60, 62, 64, 65, 67, 69, 71, 72]
	//# dorian = [2,1,2,2,2,1,2] DEFGABCD [0, 62, 64, 65, 67, 69, 71, 72, 74]
 	//# phrygian = [1,2,2,2,1,2,2] EFGABCDE [0, 64, 65, 67, 69, 71, 72, 74, 76]
	//# lydian = [2,2,2,1,2,2,1] FGABCDEF [0, 65, 67, 69, 71, 72, 74, 76, 77]
	//# mixolydian = [2,2,1,2,2,1,2] GABCDEFG [0, 67, 69, 71, 72, 74, 76, 77, 79]
	//# aeolian = [2,1,2,2,1,2,2,] ABCDEFGA [0, 69, 71, 72, 74, 76, 77, 79, 81]
	//# locrian = [1,2,2,1,2,2,2] BCDEFGAB [0, 71, 72, 74, 76, 77, 79, 81, 83]
	
	//# Default chord bank settings. Copy to preset to override
	//# scene setup. map txpose based on circle of 5ths. 
	//# scn_preset must always be setting for preset (self)
	scene_bank[current_scene * sc_size] = [8,6,scn_preset,1,1,1,1,8,8,8,8,-1]
	
	//# chord settings
	//# psd is scale degrees for each chord in the progression
	psd = [1,3,5,-1, 2,4,6,-1, 3,5,7,-1, 4,6,1,-1, 5,7,2,-1, 6,1,3,-1, 7,2,4,-1, 1,3,5,7]
	//# other settings for the 8 chord slots in this current scene
	prog_durs = [4,4,4,4,4,4,4,4]
	prog_bass = [1,2,3,4,5,6,7,1]
	prog_invs = [0,0,0,0,0,0,0,3]
	//# chord notes always stored in an ascending order. 
	//# So 461 will have an octave added to the 1. 
	//# prog_invs are applied at NoteOut. No effect on how notes stored here
				
	if scn_preset = 1
  	scene_bank[current_scene * sc_size] = [0,6,scn_preset,1,1,1,1,8,8,8,8,-1]
	  chord_bank[(current_scene * 100) + 0]  = [-1,-1,-1,-1,0,0,-1]
	  chord_bank[(current_scene * 100) + 10] = [-1,-1,-1,-1,0,0,-1]
	  chord_bank[(current_scene * 100) + 20] = [-1,-1,-1,-1,0,0,-1]
	  chord_bank[(current_scene * 100) + 30] = [-1,-1,-1,-1,0,0,-1]
	  chord_bank[(current_scene * 100) + 40] = [-1,-1,-1,-1,0,0,-1]
	  chord_bank[(current_scene * 100) + 50] = [-1,-1,-1,-1,0,0,-1]
	  chord_bank[(current_scene * 100) + 60] = [-1,-1,-1,-1,0,0,-1]
	  chord_bank[(current_scene * 100) + 70] = [-1,-1,-1,-1,0,0,-1]
	 LabelPads {An empty scene. Press shift to select a +CHORDS mode}
	 Call @SetupLayout
	elseif scn_preset = 2
		scene_bank[current_scene * sc_size] = [4,6,scn_preset,1,1,1,1,8,8,8,8,-1]
		psn = [0, 60, 62, 64, 65, 67, 69, 71, 72]
		psd = [1,3,5,-1, 5,7,2,-1, 6,1,3,-1, 4,6,1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1]
		prog_durs = [4,4,4,4,0,0,0,0]
		prog_bass = [1,5,6,4,0,0,0,0]
		prog_invs = [0,-1,-1,-1,0,0,0,0]
		Call @HandleChordBankPresetUpdate
		chord_bank[(current_scene * 100) + 40] = [-1,-1,-1,-1,0,0,-1] //overwrite with empty
	  chord_bank[(current_scene * 100) + 50] = [-1,-1,-1,-1,0,0,-1]
	  chord_bank[(current_scene * 100) + 60] = [-1,-1,-1,-1,0,0,-1]
	  chord_bank[(current_scene * 100) + 70] = [-1,-1,-1,-1,0,0,-1]
  	LabelPads {Classic I-V-vi-IV progression in C Major}
	elseif scn_preset = 3
		psn = [0, 60, 62, 64, 65, 67, 69, 71, 72]
		prog_invs = [0,0,0,0,0,0,0,4]
		Call @HandleChordBankPresetUpdate
  	LabelPads {C IONIAN Major diatonic chord set}
	elseif scn_preset = 4
		psn = [0, 62, 64, 65, 67, 69, 71, 72, 74]
		prog_invs = [0,0,0,0,0,0,3,4]
		Call @HandleChordBankPresetUpdate
  	LabelPads {D DORIAN diatonic chord set}
  elseif scn_preset = 5
		psn = [0, 64, 65, 67, 69, 71, 72, 74, 76]
		prog_invs = [0,0,0,0,0,3,3,4]
		Call @HandleChordBankPresetUpdate
  	LabelPads {E PHRYGIAN diatonic chord set}
  elseif scn_preset = 6
		psn = [0, 65, 67, 69, 71, 72, 74, 76, 77]
		prog_invs = [0,0,0,0,3,3,3,4]
		Call @HandleChordBankPresetUpdate
  	LabelPads {F LYDIAN diatonic chord set}
  elseif scn_preset = 7
		psn = [0, 67, 69, 71, 72, 74, 76, 77, 79]
		prog_invs = [0,0,0,3,3,3,3,4]
		Call @HandleChordBankPresetUpdate
  	LabelPads {G MIXOLYDIAN diatonic chord set}
  elseif scn_preset = 8
		psn = [0, 69, 71, 72, 74, 76, 77, 79, 81]
		prog_invs = [0,0,3,3,3,3,3,4]
		Call @HandleChordBankPresetUpdate
  	LabelPads {A AEOLIAN Natural Minor diatonic chord set}
  elseif scn_preset = 9
		psn = [0, 71, 72, 74, 76, 77, 79, 81, 83]
		prog_invs = [0,3,3,3,3,3,3,4]
		Call @HandleChordBankPresetUpdate
  	LabelPads {B LOCRIAN diatonic chord set}
  elseif scn_preset = 10
	  scene_bank[current_scene * sc_size] = [4,6,10,1,1,1,1,8,8,8,8,-1]
	  chord_bank[(current_scene * 100) + 0] = [9,12,16,-1,4,0,69]
	  chord_bank[(current_scene * 100) + 10] = [11,14,17,-1,4,0,71]
	  chord_bank[(current_scene * 100) + 20] = [0,4,7,-1,4,3,72]
	  chord_bank[(current_scene * 100) + 30] = [2,5,9,-1,4,3,74]
	  chord_bank[(current_scene * 100) + 40] = [4,8,11,-1,4,3,76]
	  chord_bank[(current_scene * 100) + 50] = [5,9,12,-1,4,3,77]
	  chord_bank[(current_scene * 100) + 60] = [7,10,13,-1,4,3,7]
	  chord_bank[(current_scene * 100) + 70] = [9,12,16,-1,4,3,69]
	  LabelPads {Minor triadic harmony (from Natural & Harmonic minor diatonic chords)} 
 	  Call @SetupLayout
	elseif scn_preset = 11
	  scene_bank[current_scene * sc_size] = [4,6,10,1,1,1,1,8,8,8,8,-1]
	  chord_bank[(current_scene * 100) + 0] = [9,12,16,19,4,0,69]
	  chord_bank[(current_scene * 100) + 10] = [11,14,17,21,4,0,71]
	  chord_bank[(current_scene * 100) + 20] = [0,4,7,11,4,4,72]
	  chord_bank[(current_scene * 100) + 30] = [2,5,9,12,4,4,74]
	  chord_bank[(current_scene * 100) + 40] = [4,8,11,14,4,4,76]
	  chord_bank[(current_scene * 100) + 50] = [5,9,12,16,4,4,77]
	  chord_bank[(current_scene * 100) + 60] = [7,10,13,17,4,4,7]
	  chord_bank[(current_scene * 100) + 70] = [9,12,16,19,4,4,69]
	  LabelPads {Diatonic 7th chords Minor (Hybrid)} 
	  Call @SetupLayout
  elseif scn_preset = 12
    scene_bank[current_scene * sc_size] = [4,6,13,1,1,1,1,8,8,8,8,-1]
    chord_bank[(current_scene * 100) + 0] = [0,4,7,-1,4,0,0]
    chord_bank[(current_scene * 100) + 10] = [0,4,7,-1,4,-1,0]
    chord_bank[(current_scene * 100) + 20] = [0,4,7,-1,4,1,0]
    chord_bank[(current_scene * 100) + 30] = [0,3,7,-1,4,0,0]
    chord_bank[(current_scene * 100) + 40] = [0,2,7,-1,4,0,0]
    chord_bank[(current_scene * 100) + 50] = [0,5,7,-1,4,0,0]
    chord_bank[(current_scene * 100) + 60] = [0,4,7,11,4,0,0]
    chord_bank[(current_scene * 100) + 70] = [0,4,7,10,4,0,0]
 		LabelPads {Noodling the tonic - MAJOR} 
 		Call @SetupLayout
  elseif scn_preset = 13
    scene_bank[current_scene * sc_size] = [4,6,13,1,1,1,1,8,8,8,8,-1]
    chord_bank[(current_scene * 100) + 0] = [9,12,16,-1,4,0,9]
    chord_bank[(current_scene * 100) + 10] = [9,12,16,-1,4,-1,9]
    chord_bank[(current_scene * 100) + 20] = [9,12,16,-1,4,1,9]
    chord_bank[(current_scene * 100) + 30] = [9,11,16,-1,4,0,9]
    chord_bank[(current_scene * 100) + 40] = [9,14,16,-1,4,0,9]
    chord_bank[(current_scene * 100) + 50] = [9,12,16,-1,4,0,9]
    chord_bank[(current_scene * 100) + 60] = [9,12,16,19,4,0,9]
    chord_bank[(current_scene * 100) + 70] = [9,13,16,19,4,0,9]
 		LabelPads {Noodling the tonic - MINOR} 
 		Call @SetupLayout
  endif
@End

@HandleChordBankPresetUpdate
	chord_slot = (current_scene * 100)
	for c = 0 to 7
		//# get from scale note array using scale degree as index
		cn1 = psn[ psd[(c*4) + 0] ]
		cn2 = psn[ psd[(c*4) + 1] ]
		cn3 = psn[ psd[(c*4) + 2] ]
		//# Log {CNs }, cn1, cn2, cn3
		if psd[(c*4) + 3] >= 0 //# 7th note is added
			cn4 = psn[ psd[(c*4) + 3] ]
		else
			cn4 = -1
		endif
		//# return scale degrees to root inversion
		if cn2 < cn1
			cn2 = cn2 + 12
			//# Log {cn2 after inv: }, cn2
		endif
		if cn3 < cn2
			cn3 = cn3 + 12
			//# Log {cn3 after inv: }, cn3
		endif
		if (cn4 >= 0) and (cn4 < cn3)
			cn4 = cn4 + 12
			//# Log {cn4 after inv: }, cn4
		endif
		chord_bank[chord_slot + (c*10) + 0] = cn1
		chord_bank[chord_slot + (c*10) + 1] = cn2
		chord_bank[chord_slot + (c*10) + 2] = cn3
		chord_bank[chord_slot + (c*10) + 3] = cn4
		chord_bank[chord_slot + (c*10) + 4] = prog_durs[c]
		chord_bank[chord_slot + (c*10) + 5] = prog_invs[c]
		chord_bank[chord_slot + (c*10) + 6] = psn[ prog_bass[c] ]
	endfor
	Call @SetupLayout
@End

@LogCurrentSceneToPresetFormat
	//# Logs current scene to a format which can be added to the preset section
	Log {======= END PRESET LOG =======}
	Log {	 Call @SetupLayout}
	Log {	 LabelPads YOUR PRESET NAME -in curly brackets!! } 
	chord_slot = (current_scene * 100)
	for c = 7 to 0
		c_loc = (chord_slot + (c*10))
		n1 = chord_bank[c_loc]
		n2 = chord_bank[c_loc + 1]
		n3 = chord_bank[c_loc + 2]
		n4 = chord_bank[c_loc + 3]
		d = chord_bank[c_loc + dur_slot]
		i = chord_bank[c_loc + inv_slot]
		b = chord_bank[c_loc + bass_slot]
		Log {	   chord_bank[(current_scene * 100) + }, c*10, {] = [}, n1,{,}, n2,{,}, n3,{,}, n4,{,}, d,{,}, i,{,}, b, {]}
	endfor
	Log {	   scene_bank[},{current_scene * sc_size}, {] = [4,6,}, num_sc_presets+1, {,0,0,0,0,0,0,0,0,-1]}
	Log {elseif scn_preset = }, num_sc_presets+1
	Log {======= START PRESET LOG =======}
	Log {+ Make sure to change YOUR PRESET NAME and put it in curly brackets}
	Log {+ Update num_sc_presets variable to }, num_sc_presets+1,{ in @InitKnobVariables}
	Log {+ Copy this PRESET LOG to the end of @ChangeScenePreset before 'endif'}
	Log {++++++ INSTRUCTIONS FOR ADDING A PRESET +++++}
@End
