//# GENOCHORD - Chord generator 
@OnLoad 
	ShowLayout 2
	LabelPads {[ GENOCHORD]}
	SetShortName {GOC}
	if unassigned scene_bank //# duration in first scene
		ResetNoteStates FALSE // #reset the locker with the value FALSE!
		mode = 0 //# See @HandleModeChange for modes
		songmode = 0 //# 0:Playsong 1:SceneLocked 2:ChordLocked
		SetMetroPPQN 4
		ShowLayout 2
		scene_change_requested = -1 //# on pad down has next scene number
	 	chord_change_requested = -1 //# on pad down has next chord number
		chord_beat_count = -1
		scene_beat_count = -1
		scene_changed = FALSE
		scene_change_chord_reset = TRUE //# Goto chord 0 when user changes scene
		in_settings_mode = TRUE //# Toggle for changing modes mode
        base_starting_note = 48 //# centre point for notes out
		return_to_song_mode_requested = FALSE //# used for switching on new bar 
		rec_chord_note_count = 0 //# recording notes in chord slot
		//# used for LED feedback
		last_pad=0 
		shift_is_down=FALSE
		pad_is_down=FALSE
		knobs_controller=[15,40,41,42,43] //midi controller ch & 4 base ccs. 
		txpose_w_circle_fifths=FALSE
		copy_mode=-1
		generate_random_chord=FALSE
		chord_note_off_delay=0
		SetTimerInterval 1000
        //# Setup encoders and pads to control
        custom_pads_type=0 //# 0 Notes, 1 CC
        kntrl_knob_type=0 //# 0=Encoders 1=Regular knobs
        kntrl_output_relenc=FALSE //# TRUE=Relative encoder output +65 -63; FALSE=continuous absolute output pot //#relenc 
		invert_enc_dir=FALSE
        enc_change_dir=0 //# -1 for decrease, 1 for increase, 0 to init
		enc_inc_dec_vals=[64,64] //check MIDIByte3 val received from encoders
        knob_scale_turn=10
        enc_test_val=64
        ready_to_rec_knob_vals=FALSE // bool for setting custom knob vals
        ready_to_rec_pad_vals=FALSE // bool for setting custom pad vals
        custom_knobs = [-1, 1,2,3,4, 5,6,7,8]  // default custom knobs config
        custom_pads = [-1, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0]  // default custom pads config
        trigger_pads_val = 0 //# starting note for trigger pads. 8 pads to trigger 8 chords
        hmny_kybd_out_ch=6
        hmny_kybd_pad_notes_store=[] //# store playing notes on 16 pads so we can turn them off
        //#player modes
		player_mode=1 //# 0. THRU 1. play chords as sequenced on out channel or 2. Trigger chords usign player in channel
		player_in_channel=0
		player_out_channel=1
        harmonize_notes_in=FALSE
        log_harmony_notes=FALSE
        pedal_tone = 0 //# playable using C# - sustained note that remains constant while chords change. Scale root
		Call @TransposeCalcArrays
	  	Call @InitKnobVariables //# All knob settings on start
	  	Call @SetupChordsScenes
	  	knob_set=99
		Call @SetupKnobset99 //settings knobs
        Call @SysexMessageSetup
        Call @ChangeScenePreset
	  	Call @SetupSettingsLayout
	endif
@End

@SysexMessageSetup
	//Sending SYSEX. 
	//Method: Set msg_type=[sx_var_below]; msg_data=[an array]; len_data=[len msg_data array]; Then Call @SendSysex
	mk_sysex_header=[0x3F,0x40,0x3F,0x40,0x3F,0x40]
    len_header=6
    sx_knob_setup=3 //# knobs midi channel, followed by CC vals
    sx_knob_change=4 //# knobs value change message
    current_knob_vals=[0,0,0,0]
    last_updated_knob_vals=[0,0,0,0]
    send_feedback_to_pots=TRUE
@End

@SendKnobChangeSysex
    //# update knob FB device
    for i = 0 to 3
        current_knob_vals[i] = (Round GetKnobValue i)
        last_updated_knob_vals[i] = (Round GetKnobValue i)
    endfor
    CopyArray current_knob_vals, msg_data, 4
    msg_type = sx_knob_change
    len_data=4
    Call @SendSysex
@End

@UpdateOtherKnobsIfRequired
    //# on knob change check if other knobs have changed and update controller 
    other_knobs_have_changed = FALSE
    for i = 0 to 3
        if (i <> last_knob) and last_updated_knob_vals[i] <> GetKnobValue i 
            other_knobs_have_changed = TRUE
        endif
    endfor
    if other_knobs_have_changed
        Call @SendKnobChangeSysex
    endif 
@End

@SendSysex
    sysex_msg=[]
    CopyArray mk_sysex_header, sysex_msg, len_header //set header to MK msg
	sysex_msg[len_header] = msg_type //add the message type to the sysex msg
	CopyArray msg_data, sysex_msg[len_header+1], len_data //add msg data to sysex msg
	SendSysex sysex_msg, len_header+len_data+1 //Send header, msg_type msg_data
@End

@InitKnobVariables
	//# Any knobset knob should have a setting here
	scn_duration = 0 
	scn_txpose = 0 
	scn_preset = 2
	scn_out4_on = 1
	num_sc_presets = 13
	chrd_duration = 0
	chrd_inversion = 0
	slct_chord_root = 0 //# Select chord mode only
  	slct_chord_type = 0 //# Select chord mode only
  	slct_chord_inversion = 0 //# Select chord mode only
	//# Construct chords
	constructed_root = 0
	constructed_3rd = 2
	constructed_5th = 1
	constructed_7th = 3	
 	FillArray sort_list, 0 //# empty array for sorting chord notes as arrive

	//# Selecting chords from types mode
	num_chord_types = 11 //# Chord types for select mode
	chord_types[0] = [4,7,-1] //# Major
	chord_types[5] = [3,7,-1] //# Minor
	chord_types[10] = [3,6,-1] //# Diminished
	chord_types[15] = [4,8,-1] //# Augmented
	chord_types[20] = [2,7,-1] //# Sus2
	chord_types[25] = [5,7,-1] //# Sus4
	chord_types[30] = [3,7,8] //# Minor 6th
	chord_types[35] = [4,7,9] //# Major 6th
	chord_types[40] = [3,7,10] //# Minor 7th
	chord_types[45] = [4,7,10] //# Dom 7th
	chord_types[50] = [4,7,11] //# Major 7th

	//# Intervals for constructing chords
	c3rd_intervals = [2, 3, 4, 5] //# sus2, min, maj, sus4
	c5th_intervals = [6, 7, 8] //# dim (b5), P5, aug (#5)
	c7th_intervals = [-1, 8, 9, 10, 11] //# min6 (b6), maj6, min7 (b7), maj7	
	
	//keeping track of held notes over chord changes
	//When a chrd chgs. Turn off all held notes and replace with notes of new chord
	update_held_notes_on_chord_change=TRUE //FALSE will allow held notes to continue as originally triggered
	num_mel_voices=6 //melody chans max polyphony. for tracking melody notes over chord changes we limit for CPU
	FillArray mel_note_voices, -1, num_mel_voices*16
	FillArray held_chord_notes, -1, 16 //Tracking the chord note chans. 1 note per chan max IN.
	FillArray held_chord_oct_adj, 0, 16 	//Harmony note octave in effect octave chord notes are sent out on
@End

@SetupChordsScenes
	current_scene = 0 // #0-7 Pads 0-7
	current_chord = 0 // #0-7 Pads 8-15
	chord_slot=0
	//# scene config: [duration, txpose, preset, mg1-4_modes, out_ch1-4 modes]
	//# MG Modes determine how harmonization occurs per scene
	sc_txp_slot = 1
	sc_preset_slot = 2
	sc_size = 15 //# ^ above slots + duration = 11 + 4 spare for even sizing 
	rnd_scn_chance=0 //% chance scene change will be to a random one
	rnd_chrd_chance=0 //% chance chord change will be to a random one
	num_scns_with_dur=0 //RND only selects scenes with duration
	num_chrds_with_dur=[0,0,0,0, 0,0,0,0] //RND only selects chords with duration per scene
	//# chord = [note1, note2, note3, note4, duration, inv, bass, suggestion]
	dur_slot = 4 //# fixed location for duration for chords
	inv_slot = 5
	bass_slot = 6 //not used
	sugg_slot = 7 //# for chord suggestion selected choice
 
  	//# Create empty chord and scene arrays
  	for s = 0 to 7 
	  	//# Create 8 scene arrays in scene_bank
	  	scene_bank[s*sc_size] = [0,6,1,1,1,1,1,8,8,8,8,-1]
		for c = 0 to 7
			//# Create 8 chord arrays for each scene
			chord_bank[(s*100) + (c*10)] = [-1, -1, -1, -1, 0, 0, -1, 0]
		endfor
	endfor
	
	//# indexing them by scene size (sc_size). Sample scenes
	//# eg scene2 ... scene_bank[sc_size * sc#(0-7)] = [2,6,0,0,0,0,0,1,1,1,1]
	scene_bank[0] = [1,6,1,1,1,1,1,8,8,8,8,-1]
	//# Example chords: increment in 10's in each scene, new scenes on the 100
	//# eg: chord_bank[10] = [67, 71, 74, 77, 8, 0, -1] //# Scene1 Chord 2
	//# eg: chord_bank[100] = [65, 69, 72, 76, 8, 0, -1] //# Scene2 Chord 1
	//# eg: chord_bank[110] = [69, 72, 76, 79, 4, 0, -1] //# Scene2 Chord 1
  
	FillArray all_chord_scales, -1, 1024 //store for the scale used when each chord (up to 64) is active 
	FillArray current_chord_scale, -1, 12 //the active chord_scale copied from all_chord_scales
	FillArray all_inv_chord_scales, -1, 1024 //store for the playable chord note pitches for each chord post inversion + txpose
	FillArray curr_inv_chord_scale, -1, 12 //Inverted chord note scale 0,4,7,11 indexes for chord notes
	//map incoming note to get inversion....C=root invert up or down from C
	inversions_for_gated_chord=  [0,1,2,3,4,0,0,0,-4,-3,-2,-1]
	//triad inversions
	//we use these for mode2 gated chord for quick access to adjust chord_scale notes for inversion 
	triad_inversion_adjustments[0] = [-12,-12,-12,0] //inversion -4 
	triad_inversion_adjustments[4] = [-12,-12,-12,0] //inversion -3 
	triad_inversion_adjustments[8] = [0,-12,-12,0] //inversion -2 
	triad_inversion_adjustments[12]= [0,0,-12,0] //inversions -1 
	triad_inversion_adjustments[16]= [0,0,0,0] //root inversion 
	triad_inversion_adjustments[20]= [12,0,0,0] //1st inversion 
	triad_inversion_adjustments[24]= [12,12,0,0] //2nd inversion 
	triad_inversion_adjustments[28]= [12,12,12,0] //3rd inversion 
	triad_inversion_adjustments[32]= [12,12,12,0] //4th inversion 
	//tetrad inversions 
	tetrad_inversion_adjustments[0] = [-12,-12,-12,-12] //inversion -4
	tetrad_inversion_adjustments[4] = [0,-12,-12,-12] //inversion -3
	tetrad_inversion_adjustments[8] = [0,0,-12,-12] //inversion -2
	tetrad_inversion_adjustments[12]= [0,0,0,-12] //inversions -1
	tetrad_inversion_adjustments[16]= [0,0,0,0] //root inversion
	tetrad_inversion_adjustments[20]= [12,0,0,0] //1st inversion
	tetrad_inversion_adjustments[24]= [12,12,0,0] //2nd inversion
	tetrad_inversion_adjustments[28]= [12,12,12,0] //3rd inversion
	tetrad_inversion_adjustments[32]= [12,12,12,12] //4th inversion
	//Modes for processing incoming notes 0:Off 1:Harmonize 2:GatedChord Inv 3:Harmonize2 4:PlayChord 5: TRIGGER 6:OFF
	set_all_mc_to=0 //#Setting all midi channels to x def is thru
	FillArray mel_note_velos, 100, 127 //default value for stored velocity when re-trig mel notes on chord change 
	apn_adj=0 //apn_adj allow passing notes  0:no 1:yes
	//# Scale definitions for midi in key, scale handling
	//# Allowed scales for midi in
	num_scale_types = 2
	allowed_scales = [1,2] 
	//# incoming midi key, scale. default C Major
	selected_midi_in_root = 0 // # root note -11 (C-B) 
	selected_midi_in_scale = 0 // #see allowed_scales  
	midi_in_scales[10] = [0,2,4,5,7,9,11]  //# major
	midi_in_scales[20] = [0,2,3,5,7,8,10] // #minor_nat
	midi_in_scales[30] = [0,2,3,5,7,9,10]  // #minor_mel
	midi_in_scales[40] = [0,2,3,5,7,9,11]  // #minor_har
	Call @GetMidiInScale
@End

@GetMidiInScale
	PresetScale allowed_scales[selected_midi_in_scale]
	SetRootNote selected_midi_in_root
	// #create an array with the notes of selected key scale
	scale_loc = allowed_scales[selected_midi_in_scale] * 10
	for scale_degree = 0 to 6
		// #ms is incoming_midi_scale
		midi_in_scale_notes[scale_degree] = (selected_midi_in_root + midi_in_scales[scale_loc + scale_degree]) % 12 
	endfor
	//Log {Passing notes: }, (NoteName midi_in_scale_notes[1]), { }, (NoteName midi_in_scale_notes[3]), { }, (NoteName midi_in_scale_notes[5])
	//Log {Play chord notes with: }, { }, (NoteName midi_in_scale_notes[0]), { }, (NoteName midi_in_scale_notes[2]), { }, (NoteName midi_in_scale_notes[4]), { }, (NoteName midi_in_scale_notes[6])
	//Log {Incoming melody scale: }, RootNoteName, { }, ScaleName
@End

@OnHostStart
	//# log {--- HOST START ---}
	//# Start beat count on same beat as host
	//# In AUM getting HostBeat to start on 0 seems flaky
	//# Fixed by BramBos in June2020
	//Log HostBar, { : }, HostBeat, { = }, (HostBeatsPerMeasure * HostBar) + HostBeat
	chord_to_set=current_chord
	chord_note_off_delay=0
	Call @SetChordScale 
	if (HostBeat = 0) and (HostBar = 0)
		//# starting playback from beginning		
		chord_beat_count = -1
		scene_beat_count = -1
		scene_changed = FALSE
		if (songmode = 0)
			current_scene = 0
			current_chord = 0
		elseif (songmode = 1)
			current_chord = 0
		endif
		if mode > 2 
			//# No chord Rec, Select or Delete in playback
			mode = 0
		endif
	else
		//# continuing playback
		//# Could do nothing and allow continue with vars unchanged
		//# but in case use can jump timeline we are doing this to keep HostBeat aligned and chord/Scene at same relative positions.
		scene_completed_bars = scene_beat_count % HostBeatsPerMeasure
		chord_completed_bars = chord_beat_count % HostBeatsPerMeasure
		scene_beat_count = scene_completed_bars + HostBeat
		chord_beat_count = chord_completed_bars + HostBeat
	endif
	//Log {---- Host Started ----}
	Call @PlayChords
	Call @SetupLayout
@End

@OnHostStop
	//# Log {---- Host Stopped ---- }, scene_beat_count, { - }, chord_beat_count 
	//# reset held notes
	chord_note_off_delay=5
	Call @TurnOffChordNotes
	FillArray mel_note_voices, -1, num_mel_voices*16
	FillArray held_chord_notes, -1, 16 //Tracking the chord note chans. 1 note per chan max IN.
	FillArray held_chord_oct_adj, 0, 16 	//Harmony note octave in effect octave chord notes are sent out on
    Call @ResetBeatCounts
    current_chord=0
    chord_to_set=0
    Call @SetChordScale
    Call @SetupLayout
    if mode=0
        LabelPads {[ GENOCHORD ]    Scene}, current_scene+1, {   Bar}, (Div scene_beat_count, HostBeatsPerMeasure)+1, {   Beat }, scene_beat_count+1, {/}, (current_scene_duration) 
    endif
@End 

@ResetBeatCounts
	//# Re-start when mode or scene changes
	scene_beat_count = 0
	chord_beat_count = 0
	//# Log {Beat counts reset}
@End

@OnMetroPulse
    if player_mode <> 0
        //# if CurrentMetroPulse is on last pulse check chord & scene changes. if they exist turn off notes now
        //# leave the actual chord and scene change to the on new beat 
        //# log {CMP }, CurrentMetroPulse, {  % }, CurrentMetroPulse % 4
        if CurrentMetroPulse % 4 = 3 
            //# log {last pulse before new beat}
            look_ahead_scene_beat_count = scene_beat_count + 1
            look_ahead_chord_beat_count = chord_beat_count + 1
            current_scene_duration = scene_bank[current_scene * sc_size]  * HostBeatsPerMeasure //# IN BEATS!
            chord_slot = (current_scene * 100) + ((current_chord) * 10)
            current_chord_duration = chord_bank[chord_slot + dur_slot]
            if (scene_change_requested > -1) and (HostBeat = 0)
                //# user requested scene change and its a new bar (& return to song)
                //# Log {Handling scene change request. It a new bar}
                Call @TurnOffChordNotes
                Call @HandleSceneChange
            elseif (look_ahead_scene_beat_count >= current_scene_duration)
                Call @TurnOffChordNotes
            elseif (chord_change_requested > -1)
                //# User requested chord change
                Call @TurnOffChordNotes
            elseif (look_ahead_chord_beat_count >= current_chord_duration) and (current_chord_duration>0) 
                Call @TurnOffChordNotes
                //# log {Turning off chord notes before new bar}
            endif
        endif
    endif
@End

@OnNewBar
	//# Log {--- new bar ---}
@End

@OnNewBeat
    //#Log {-- new beat --}
    if player_mode <> 0
        //# increment beat counts xonb
        scene_beat_count = scene_beat_count + 1
        chord_beat_count = chord_beat_count + 1
        
        //# Handle Scene and Chord changes
        current_scene_duration = scene_bank[current_scene * sc_size]  * HostBeatsPerMeasure //# IN BEATS!
        chord_slot = (current_scene * 100) + ((current_chord) * 10)
        current_chord_duration = chord_bank[chord_slot + dur_slot]
        current_host_beat = (HostBar * HostBeatsPerMeasure) + HostBeat
        
        //# Log {Scene beats left: }, current_scene_duration - scene_beat_count
        //# Log {Chord beats left: }, current_chord_duration - chord_beat_count
    
        //# Chord progression -- Order of operations
        if player_mode = 1 //# play sequence chord progression
            if (scene_change_requested > -1) and (HostBeat = 0)
                //# user requested scene change and its a new bar (& return to song)
                //# Log {Handling scene change request. It a new bar}
                Call @TurnOffChordNotes
                Call @HandleSceneChange
            elseif (scene_beat_count >= current_scene_duration)
                //# its time to increment scene
                Call @TurnOffChordNotes
                Call @HandleSceneChange
            elseif (chord_change_requested > -1)
                //# User requested chord change & its a new beat
                Call @TurnOffChordNotes
                Call @HandleChordChange
            elseif (chord_beat_count >= current_chord_duration) and (current_chord_duration>0) 
                Call @TurnOffChordNotes
                Call @HandleChordChange
            endif
        endif
        if mode=0
            LabelPads {[ GENOCHORD ]    Scene}, current_scene+1, {   Bar}, (Div scene_beat_count, HostBeatsPerMeasure)+1, {   Beat }, scene_beat_count+1, {/}, (current_scene_duration) 
        endif
    endif
@End

@HandleSceneChange
	//# Work out which scene is next 
	scene_changed = TRUE
	if return_to_song_mode_requested
		return_to_song_mode_requested = FALSE
	endif
  	if scene_change_requested > -1
  		current_scene = scene_change_requested
		scene_change_requested = -1
	elseif (songmode > 0)
  		current_scene = current_scene
  	elseif (current_scene = 7) //# End of song 
    	current_scene = 0 //# TODO: Handle end of song
  	elseif scene_bank[(current_scene * sc_size) + sc_size] <= 0 //# also song end
  		current_scene = 0 //# no duration in next scene return to beginning
  	else
		current_scene = current_scene + 1 //# Going to next
  	endif
  	if ((Random 1,99) < rnd_scn_chance) and songmode=0 //%chance of random scene change if not scene locked
    	rnd_scn = (Random 0, num_scns_with_dur) //get random scene with duration
		if scene_bank[rnd_scn * sc_size]>0 and chord_bank[(rnd_scn * 100) + dur_slot]>0
			current_scene=rnd_scn //if rnd_scn has scene and first chord duration
		endif
	endif
  	Call @ResetBeatCounts
  	//Log {----- SCENE CHANGE -----}, {S}, current_scene+1
  	Call @HandleChordChange //# Scene change effect chord change
@End

@HandleChordChange
	//# Work out what the next chord is 
	chord_slot = (current_scene * 100) + ((current_chord) * 10)
	if (chord_change_requested > -1)
		current_chord = chord_change_requested
		chord_change_requested = -1 //# reset request flag
		if songmode < 2
			songmode = 2 //# Lock to chord if user requests chord change
 		endif
 	elseif (scene_change_requested > -1) //# also handle chord change
		current_chord = 0
		scene_change_requested = -1
		scene_changed = FALSE
  	elseif scene_changed
		//# reset chord to 0 on scene change if songmode < 2
		if (songmode <= 1)
			current_chord = 0
		endif
		scene_changed = FALSE
	elseif (songmode = 2) //# Loop current chord & Scene
    	current_chord = current_chord
  	elseif (current_chord = 7) //# Wrap playback
    	current_chord = 0
  	elseif (chord_bank[(chord_slot+10) + dur_slot] <= 0)
  		current_chord = 0 //# no duration no next chord (chord_slot + 10)
	else
		current_chord = current_chord + 1
	endif
	if ((Random 1,99) < rnd_chrd_chance) and songmode<2 //%chance of random chord change if not chord locked
    	rnd_chrd = (Random 0, num_chrds_with_dur) //get random chord with duration
		if chord_bank[(current_scene * 100) + (rnd_chrd * 10) + dur_slot]>0
			current_chord=rnd_chrd //if rnd_chrd has duration 
		endif
	endif
	chord_to_set=current_chord
	Call @SetChordScale
  	chord_beat_count = 0 //# reset chord beat count on new chord
	//turn off notes over chord change and re-trigger melody and harmony channel notes
	Call @HandleNotesHeldOverChordChange 
	Call @PlayChords
	//# Label pads
  	if not in_settings_mode
		LabelPads {[ GENOCHORD ]  Scene: }, current_scene+1, { Chord: }, current_chord+1
  	endif
  	//Log {----- CHORD CHANGE -----}, {C}, current_chord+1
  	Call @SetupLayout
	Call @OnPadDown_KnobSetSelect
@End

@PlayChords
	// Active channels set to Play Chords mode (4) send out chord notes on that channel
	if HostRunning and player_mode=1 and harmonize_notes_in=FALSE
		chord_slot = (current_scene * 100) + ((current_chord) * 10)
		current_chord_duration = chord_bank[chord_slot + dur_slot]
		chord_formed = curr_inv_chord_scale[0]>=0 and curr_inv_chord_scale[4]>=0 and curr_inv_chord_scale[7]>=0
		if current_chord_duration>0
            index_to_chord_notes=[0,4,7,11]
            Call @TurnOffChordNotes
            for n = 0 to 3
                note_to_play = curr_inv_chord_scale[ index_to_chord_notes[n] ] 		
                if note_to_play > 0
                    SendMIDINoteOn player_out_channel, note_to_play, 100
                    SetNoteState player_out_channel, n, note_to_play
                endif
            endfor
		endif
	endif 
@End

@HandleNotesHeldOverChordChange
	if HostRunning //turn off notes over chord change and re-trigger melody and harmony channel notes
        if player_mode=2 and update_held_notes_on_chord_change //play chord mode 
            Call @TurnOffChordNotes //turn off all chord notes on chord change & update notestate
            if held_chord_notes[player_out_channel]>=0
                trigger_note_oct_adj = 0  //notes 48-59 no change
                midi_note=held_chord_notes[c] // the incoming note determines what we send out
                Call @SendOutChordNotes //Send out new notes for held chord notes & update notestate
            endif	
        endif
    endif
@End

@LogCurrentInfo
	chord_slot = (current_scene * 100) + ((current_chord) * 10)
	current_chord_duration = chord_bank[chord_slot + dur_slot]
	current_scene_duration = scene_bank[current_scene * sc_size]
	Log {Playing: Scene: }, current_scene+1, { }, scene_beat_count+1, {/}, (current_scene_duration * HostBeatsPerMeasure), { beats}, { Chord:}, current_chord+1, { }, chord_beat_count+1, {/}, current_chord_duration, { beats}, { Mode: }, mode, { HostBeat: }, HostBeat+1
@End

@OnPadDown
    last_pad = LastPad // so midi in can simulate LastPad
	Call @OnPadDown2 //midi input cant trigger @OnPadDown, It calls @OnPadDown2
@End

@OnPadDown2
	//# Splitting this event into separate handlers
	shift_is_down=FALSE //protect against unwanted shift releases not happening
	pad_is_down=TRUE
    if mode=8
        Call @PadDownMidiLearn
	elseif in_settings_mode 
		if HostRunning and (last_pad>1 and last_pad<=8)
			LabelPads {NOT ALLOWED WHEN HOST RUNNING}
			Exit //# Only return to song allowed in playback
		elseif last_pad=0
			//# Return to song mode requested
			return_to_song_mode_requested = TRUE
			scene_change_requested = current_scene
			in_settings_mode = FALSE
			songmode = 0
			mode = 0
			ColorPad 0, 3
			ColorPad 8, 3
		elseif (last_pad = 1)
			in_settings_mode = FALSE
			mode=0
			Call @SetupLayout
		elseif (last_pad>=2 and last_pad<=4) //# +CHORDS MODES
			mode = last_pad-1 //# shifting mode to add kontroller slave in menu
			//Log {MODE:}, mode-1
			in_settings_mode = FALSE
		elseif last_pad=5
			StartTimer
			timer_type=1
			LabelPads {HOLD PAD DOWN TO GENERATE CHORD PROGRESSION FOR SCENE }, current_scene+1
			Exit
        elseif last_pad=8
            //configure midi control knobs
            mode=last_pad
		elseif last_pad=9
            //# Harmony keyboard 
            mode=last_pad
            in_settings_mode = FALSE
            Call @SetupLayout
        elseif last_pad=10
            //# harmonize_notes_in mode
            harmonize_notes_in = not harmonize_notes_in
            mode=last_pad
            Call @SetupSettingsLayout
            if harmonize_notes_in
                LabelPads {[ HARMONY MODE ] Chords muted. CEGB play chord notes. C# pedal, G# pedal+5th}
            endif
        elseif last_pad=12
            // log_harmony_notes 
            log_harmony_notes = not log_harmony_notes
            mode=last_pad
            Call @SetupSettingsLayout
            if log_harmony_notes
                LabelPad 12, {Logging. Tap to stop}
            endif
		elseif (last_pad=11 or last_pad=13)
			//# midi setup modes - dont exit in_select_mode
			mode = last_pad
			Call @SetupSettingsLayout
    	elseif (last_pad = 13)
			Call @LogCurrentSceneToPresetFormat
			LabelPads {Scene preset data printed. Check log!}
			Exit
		elseif (last_pad = 14) //All Notes off
			mode=last_pad
			Call @AllNotesOff
			LabelPad last_pad, {Done!}
        elseif (last_pad=15) //# Trigger chords base note
            mode=last_pad
            Call @SetupSettingsLayout
            LabelPads {Trigger chords with notes from }, (NoteName trigger_pads_val, YES), { to }, (NoteName trigger_pads_val+7, YES), { on channel }, player_in_channel+1, { (*CH aka }, player_in_channel, { )} 
		else
			mode = last_pad
			in_settings_mode = FALSE
		endif
		Call @HandleModeChange
		Call @SetupLayout
	//# NOT IN SETTINGS MODE...
	elseif NOT in_settings_mode
		//# handle mode actions if record or reset else do knob scene change
		if not (mode=7 or copy_mode=2 or mode=9)
			Call @OnPadDown_SceneChordChange //dont change if deleting or copy/pasting or in keyboard mode
		endif	
	 	Call @OnPadDown_KnobSetSelect
		if (mode = 3) and (last_pad > 7)
			Call @SetupLayout
	  	    rec_chord_note_count = 0
  		    LabelPad current_chord+8, {...waiting}
  		    ColorPad current_chord+8, 1
		elseif (mode = 6) //# COPY/PASTE
            //# only call CP if pad and copy mode correspond
            if copy_mode=0 and last_pad<=7
                Call @CopyPaste //# copy paste scene
            elseif copy_mode=1 and last_pad>=8 
                Call @CopyPaste //# copy paste chord
            endif
		elseif (mode=7) and (last_pad <= 7) //# reset mode
    	    //Log {Reset scene called}
    	    Call @ResetScene   
 	 	elseif (mode=7) and (last_pad >= 7)
    	    //Log {Reset chord called}
    	    Call @ResetChord
        elseif mode=9
            Call @PadDownHarmonyKeyboard
  	    endif
	    if NOT HostRunning and (last_pad >= 8) and mode <> 9
		    chord_slot = (current_scene * 100) + ((current_chord) * 10)
		    current_chord_duration = chord_bank[chord_slot + dur_slot]
		    chord_formed = curr_inv_chord_scale[0]>=0 and curr_inv_chord_scale[4]>=0 and curr_inv_chord_scale[7]>=0
		    if current_chord_duration>0
                // can only have one chord note per channel playing at any one time, so make sure turned off first
                index_to_chord_notes=[0,4,7,11]
                Call @TurnOffChordNotes 
                for n = 0 to 3
                    note_to_play = curr_inv_chord_scale[ index_to_chord_notes[n] ] 		
                    if note_to_play > 0
                        SendMIDINoteOn player_out_channel, note_to_play, 100
                        SetNoteState player_out_channel, n, note_to_play
                    endif
                endfor
            endif
	    endif
        if player_mode = 0 and HostRunning
            LabelPads {Stop host or turn off Thru mode}
        endif
	endif
@End			

@AllNotesOff //send midi note off for all channels - handle stuck notes
	for ch = 0 to 15
		Call @SendMidiOffForCh
	endfor
@End

@SendMidiOffForCh //send midi note off for a channel (ch) - handle stuck notes
	for n = 0 to 127
		SendMIDINoteOff ch, n, 64, (n*5) //handle stuck notes with 5ms delay on send
	endfor
@End

@OnPadUp
	last_pad=LastPad
    Call @OnPadUp2
@End

@OnPadUp2
	pad_is_down=FALSE
	if NOT HostRunning and (last_pad >= 8) and (mode < 8)
		current_chord_duration = chord_bank[chord_slot + dur_slot]
		if current_chord_duration>0
            Call @TurnOffChordNotes
		endif
    endif
	StopTimer
    ready_to_rec_knob_vals=FALSE
    ready_to_rec_pad_vals=FALSE
    if mode = 8
        Call @SetupPadsLayoutMidiConfig
    elseif mode = 9
        Call @PadUpHarmonyKeyboard
    endif
    if (kntrl_knob_type <> 0) and send_feedback_to_pots
        Call @SendKnobChangeSysex
    endif
@End

@HandleModeChange
	//# Handle Labels
	if mode = 0
		LabelPads {[ GENOCHORD ]  Scene: }, current_scene+1, { Chord: }, current_chord+1 
		Call @SetupKnobset0
		songmode = 0
	elseif mode = 1
		LabelPads {+CHORDS SELECT: Select chord, THEN set root and type}
		songmode = 2 //# Lock to chord
		Call @SetupKnobset2
	elseif mode = 2
		LabelPads {+CHORDS CONSTRUCT: Use knobs to build chord}
		songmode = 2 //# Lock to chord
		Call @SetupKnobset6
	elseif mode = 3
		LabelPads {+CHORDS RECORD: Select record channel, chord pad, then play chord notes}
		songmode = 2 //# Lock to chord
		Call @SetupKnobset1
	elseif mode = 6
		//# Copy/Paste pad hit so 'copy' current scene or chord
		//# in_select_mode = FALSE its already been exited
		if copy_mode=0 //# scene
			copied_scene = current_scene
			//Log {Copied current s}, current_scene+1
			LabelPads {Current scene copied. Select a scene to paste to}
		elseif copy_mode=1 //# chord
			copied_scene = current_scene //# just for labelling
			copied_chord = current_chord
			//Log {Copied current chord }, current_chord+1
			LabelPads {Current chord copied. Select a scene, then a chord slot to paste to}
		endif
	elseif mode = 7
		LabelPads {DELETE: Select a scene or chord slot to reset}
    elseif mode = 8
        knob_set = 3
        Call @SetupKnobset3
        Call @PadDownMidiLearn
        Call @SetupPadsLayoutMidiConfig
    elseif mode = 9
        knob_set = 5
        Call @SetupKnobset5
        Call @SetUpHarmonyKeyboard    
    endif
@End

@OnPadDown_SceneChordChange
	//# handle scene/chord change 
  if (last_pad >= 0 and last_pad <= 7)
  	//# Scene change
  	scene_change_requested = last_pad
	songmode=1 //locked to scene. User pressed scene pad
  	if NOT HostRunning //# immediate change else newbeat/bar handles
  		Call @HandleSceneChange 
  	endif
	elseif (last_pad >= 8 and last_pad <= 15) 	
  	//# User Chord change 
  	chord_change_requested = last_pad - 8 //# chrd 0-7
  	songmode=2 //locked to chord. User pressed chord pad
	if NOT HostRunning //# immediate change else newbeat/bar handles
  		Call @HandleChordChange 
  	endif
  endif	
@End

@OnPadDown_KnobSetSelect
	//# choose a knob set based on pad type
	if last_pad <= 7 and (NOT in_settings_mode)
		if (mode = 1)	 //# Select quick chords 2 knobs
			Call @SetupKnobset2
		elseif (mode = 2) //# Construct chords 4 knobs
			Call @SetupKnobset6
        elseif (mode = 9) //# Harmony keyboard
			Call @SetupKnobset5
		else
			Call @SetupKnobset0
		endif
	elseif last_pad >= 8 and NOT in_settings_mode
		if (mode = 1)	
			Call @SetupKnobset2
		elseif (mode = 2) //# Construct chords 4 knobs
			Call @SetupKnobset6
        elseif (mode = 9) //# Harmony keyboard
			Call @SetupKnobset5
		else
			Call @SetupKnobset1
		endif
	elseif in_settings_mode
	  	Call @SetupKnobset99 //settings knobset
	endif
@End


@OnMidiCC
	//# Log {sending midi thru: }, MIDIChannel+1, {-}, MIDIByte2, {-}, MIDIByte3
	if MidiChannel=15 and MidiByte2>=47 and MidiByte2<=73
        Exit //# THESE BELONG TO MKNTRL SHORTCUTS
    elseif ready_to_rec_knob_vals
		custom_knobs[last_pad+1] = MIDIByte2
		Call @SetupPadsLayoutMidiConfig
		//store inc and dec values to display on knobs
        if kntrl_knob_type=0 and pad_is_down //encoder
            if MIDIByte3<64
                enc_inc_dec_vals[0] = MIDIByte3
            elseif MIDIByte3>64
                enc_inc_dec_vals[1] = MIDIByte3
            endif
        endif
		custom_knobs[0] = MIDIChannel
        Call @SetupPadsLayoutMidiConfig
        //# update knob FB device
        CopyArray custom_knobs, msg_data, 5 
        msg_type = sx_knob_setup
        len_data=5
        Call @SendSysex
    
    elseif ready_to_rec_pad_vals
        log {ready_to_rec_pad_vals}
        if last_pad=8
            custom_pads[1]=MIDIByte2
            for i = 2 to 8
                custom_pads[i]=MIDIByte2+i-1
            endfor
        elseif last_pad=9
            custom_pads[9]=MIDIByte2
            for i = 10 to 16
                custom_pads[i]=MIDIByte2+i-9
            endfor
        elseif last_pad=10
            custom_pads[17]=MIDIByte2
        endif
        Call @SetupPadsLayoutMidiConfig
        custom_pads[0] = MIDIChannel
        custom_pads_type=1 //# cc

	elseif (custom_knobs[0] <> -1 and MIDIChannel=custom_knobs[0]) and (MIDIByte2=custom_knobs[1] or MIDIByte2=custom_knobs[2] or MIDIByte2=custom_knobs[3] or MIDIByte2=custom_knobs[4])
		//Get knob number
		if MIDIByte2=custom_knobs[1] 
			last_knob=0
		elseif MIDIByte2=custom_knobs[2]
			last_knob=1
		elseif MIDIByte2=custom_knobs[3]
			last_knob=2
		elseif MIDIByte2=custom_knobs[4]
			last_knob=3
		endif

        if mode=8 // configure midi controller knobs
            if kntrl_knob_type=1 
                enc_test_val = MIDIByte3
                SetKnobValue 2, MIDIByte3 // change demo knob
            else
                if MIDIByte3>=64
                    enc_change_dir=(knob_scale_turn)/10
                else
                    enc_change_dir=(-knob_scale_turn)/10
                endif
                if invert_enc_dir
                    knob_value = enc_test_val - enc_change_dir
                else    
                    knob_value = enc_test_val + enc_change_dir
                endif
                if knob_value<0
                    knob_value=0
                elseif knob_value>127
                    knob_value=127
                endif
                enc_test_val = knob_value
                SetKnobValue 2, enc_test_val
            endif
            Call @SetupKnobset3
        else
            //Set knob value and handle change
            if kntrl_knob_type=1  
                //pot continuous absolute
                SetKnobValue last_knob, MIDIByte3 // change knob position reg knobs
            else kntrl_knob_type=0
                //relative encoder
                knob_value = GetKnobValue last_knob 
                if MIDIByte3>=64
                    enc_change_dir=(knob_scale_turn)/10
                else
                    enc_change_dir=(-knob_scale_turn)/10
                endif
                if invert_enc_dir
                    knob_value = knob_value - enc_change_dir
                else    
                    knob_value = knob_value + enc_change_dir
                endif
                if knob_value<0
                    knob_value=0
                elseif knob_value>127
                    knob_value=127
                endif
                //relative encoder output controlling cc //#relenc
                if kntrl_output_relenc 
                    //relative encoder not continuous absolutewith relenc output
                    if MIDIByte3>=64 and not invert_enc_dir
                        enc_rel_out=65
                    elseif MIDIByte3<64 and not invert_enc_dir
                        enc_rel_out=63
                    elseif MIDIByte3>=64 and invert_enc_dir
                        enc_rel_out=63
                    elseif MIDIByte3<64 and invert_enc_dir
                        enc_rel_out=65
                    endif
                endif
                SetKnobValue last_knob, knob_value
            endif
            Call @OnKnobChange2 //handle that change 
        endif

    elseif custom_pads_type=1 //# pads use cc's
        if (custom_pads[0] <> -1) and (MIDIChannel=custom_pads[0]) and (MIDIByte2>=custom_pads[1] and MIDIByte2<=custom_pads[8]) 
            for i = 1 to 8
                if MIDIByte2=custom_pads[i]
                    last_pad=i -1
                endif
            endfor
            if MIDIByte3=0
                Call @OnPadUp2
            else
                Call @OnPadDown2
            endif

        elseif (custom_pads[0] <> -1) and (MIDIChannel=custom_pads[0]) and (MIDIByte2>=custom_pads[9] and MIDIByte2<=custom_pads[16]) 
            for i = 9 to 16
                if MIDIByte2=custom_pads[i]
                    last_pad=i-1
                endif
            endfor
            if MIDIByte3=0
                Call @OnPadUp2
            else
                Call @OnPadDown2
            endif
            
        elseif (custom_pads[0] <> -1) and (MIDIChannel=custom_pads[0]) and (MIDIByte2=custom_pads[17]) //SHIFT
            if MIDIByte3=0
                Call @OnShiftUp2
            else
                Call @OnShiftDown2
            endif
        endif
    endif
@End

@SaveSelectedChordPad
	//# save to pad in select mode once chord params chosen on knobs 
	//# chord to be updated
	chord_slot = (current_scene * 100) + ((chord_to_set) * 10)
	
	//# Set fields not updated here. Default if new else saved
	if generate_random_chord
		root_updated = TRUE
		type_updated = TRUE
		inv_updated = TRUE
		rnd_durations=[2,4,4,8,8,12,16]
		chord_bank[chord_slot + dur_slot] = rnd_durations[Random 0,6] //duration
		slct_chord_root=new_root_choices[(Random 0,len_new_root_choices)]
		slct_chord_type=new_chord_type_choices[(Random 0,len_new_type_choices)]
		slct_chord_inversion=Random -1,1
	else
		chrd_duration = 4 //# default value for new chord
		if chord_bank[chord_slot + dur_slot] > 0
			chrd_duration = chord_bank[chord_slot + dur_slot]
		endif
		chord_bank[chord_slot + dur_slot] = chrd_duration
	endif
	
	//# Only update changed fields
	if root_updated or type_updated
		//# Get chord_bank location and intervals for new chord
		chord_root = slct_chord_root
		chord_type_slot = slct_chord_type * 5 //# array saved in groups 5
		chord_3rd = (slct_chord_root + chord_types[chord_type_slot])
		chord_5th = (slct_chord_root + chord_types[chord_type_slot + 1])
		chord_7th = (slct_chord_root + chord_types[chord_type_slot + 2])
		//# A triad not a tetrad
		if chord_types[chord_type_slot + 2] = -1 
			chord_7th = -1
		endif
		//# update chord values in chord_bank
		chord_bank[chord_slot] = chord_root
		chord_bank[chord_slot + 1] = chord_3rd
		chord_bank[chord_slot + 2] = chord_5th
		chord_bank[chord_slot + 3] = chord_7th
		root_updated = FALSE
		type_updated = FALSE
	endif
	if inv_updated
		chrd_inversion = slct_chord_inversion	
		chord_bank[chord_slot + inv_slot] = chrd_inversion
		inv_updated = FALSE
	endif
	chrd_to_label = chord_to_set+8
	Call @LabelChordPad
	Call @UpdateChordsWithDuration
	Call @MakeChordScale
@End

@SaveConstructedChordPad
	//# save to pad in construct mode  			
	chord_slot = (current_scene * 100) + ((chord_to_set) * 10) //# chord to be updated	
	//# Set fields not updated here. Default if new else saved
	if generate_random_chord
		chrd_duration = Random 1,16
		constructed_root=new_root_choices[(Random 0,len_new_root_choices)]
		constructed_3rd=Random 0,3
		constructed_5th=Random 0,2
		constructed_7th=Random 0,4
	else
		chrd_duration = 4 //# default value for new chord
	endif
	if chord_bank[chord_slot + dur_slot] > 0
		chrd_duration = chord_bank[chord_slot + dur_slot]
	endif
	chord_bank[chord_slot + dur_slot] = chrd_duration
	
	chord_3rd = constructed_root + c3rd_intervals[constructed_3rd]
	chord_5th = constructed_root + c5th_intervals[constructed_5th]
	if constructed_7th > 0
		chord_7th = constructed_root + c7th_intervals[constructed_7th]
	else
		chord_7th = -1
	endif
	//# Save notes to chord slot
	chord_bank[chord_slot] = constructed_root
	chord_bank[chord_slot + 1] = chord_3rd
	chord_bank[chord_slot + 2] = chord_5th
	chord_bank[chord_slot + 3] = chord_7th
	//Log {Root: }, (NoteName constructed_root), { 3rd: }, c3rd_intervals[constructed_3rd], { 5th: }, c5th_intervals[constructed_5th], { 7th: }, c7th_intervals[constructed_7th], { Chord notes }, constructed_root, { }, chord_3rd, { }, chord_5th, { }, chord_7th, { 7th: }, chord_bank[chord_slot + 3]
	chrd_to_label = chord_to_set+8
	Call @LabelChordPad
	Call @UpdateChordsWithDuration
	Call @MakeChordScale
@End

@RemakeAllChordScales
	real_current_scene=current_scene
	for s = 0 to 7
		current_scene = s 
		if scene_bank[current_scene * sc_size]>0
			Call @MakeChordScaleForScene		
		endif
	endfor
	current_scene=real_current_scene
@End

@MakeChordScaleForScene
	for i = 0 to 7
		chord_to_set=i //always except in random gen and suggest and make for scene
		chord_slot = (current_scene * 100) + ((chord_to_set) * 10) //# chord to be updated	
		if chord_bank[chord_slot + dur_slot]>0
			Call @MakeChordScale //if there is a duration on that chord
		endif
	endfor
@End

@MakeChordScale
	//create a "chord scale" to make transposing incoming notes to chord notes and chords faster
	chord_slot = (current_scene * 100) + ((chord_to_set) * 10) //# chord to be updated
	chord_scale_slot = (current_scene * 120) + ((chord_to_set) * 15)
	txpose_index = scene_bank[(current_scene * sc_size) + sc_txp_slot]
	scn_txpose = txpose_array[txpose_index] //# scene txpose amount
	
	//We need these 4 notes to make the chord scale in raw octave
	chord_root = chord_bank[chord_slot]
	chord_3rd = chord_bank[chord_slot + 1]
	chord_5th = chord_bank[chord_slot + 2]
	chord_7th = chord_bank[chord_slot + 3]
	Call @GetChordFlavour //chord_flavour is major or minor and influences chord_scale 0=major 1=minor
	Call @MakeChordNotesRawOctave
	//chord scale ignores inversion setting. User inverts using incoming octaves
	chord_scale[0]=chord_root + scn_txpose //root eg:C
	chord_scale[1]=chord_root + scn_txpose + apn_adj //root+1 eg:C#
	chord_scale[2]=chord_root + 2 + scn_txpose  //root+2 eg:D
	chord_scale[3]=chord_3rd + scn_txpose - apn_adj //3rd-1 eg:D#
	chord_scale[4]=chord_3rd + scn_txpose //3rd eg:E
	chord_scale[5]=chord_root + 5 + scn_txpose //3rd+1 eg: F aka 4th
	chord_scale[6]=chord_5th + scn_txpose - apn_adj //5th-1 eg: F#
	chord_scale[7]=chord_5th + scn_txpose //5th eg:G 
	chord_scale[8]=chord_5th + scn_txpose + apn_adj //5th+1 eg:G#
	chord_scale[9]=chord_root + 8 + chord_flavour + scn_txpose //root-3 eg: A. 
	chord_scale[10]=chord_root + 10 + chord_flavour + scn_txpose - apn_adj //root-2 eg: A# 
	if chord_7th>=0
		chord_scale[11]=chord_7th + scn_txpose //7th eg: B
	elseif chord_7th<0 //+10 minor flavor; +11major flavour
		chord_scale[11]=chord_root + 10 + chord_flavour + scn_txpose
	endif
	
	//add chord notes to chord scale post inversion for send out chord notes
	//get lowest and highest notes after inversion
	Call @HandleInversionSetting //# re-define chord notes to inverted order sets inverted_chord_name vars
	if chord_7th<0
		sort_list = [inv_chord_root, inv_chord_3rd, inv_chord_5th]
		len_list = 3
	else
	  sort_list = [inv_chord_root, inv_chord_3rd, inv_chord_5th, inv_chord_7th]
		len_list = 4
	endif
	Call @SortList
	if len_list = 3 //if no 7th then we just supplement with lowest note + oct
		sort_list[3] = sort_list[0] + 12
	endif
	//The new way chord_scale with notes in inverted order
	interval1 = sort_list[1] - sort_list[0]
	if interval1 > 2
		interval1=2
	endif
	interval2 = sort_list[3] - sort_list[2]
	if interval2 > 2
		interval2=2
	endif	
	//min interval btwn chord notes is 1, so for non-chord notes we can use +/-1 or the intervalX method
	inv_chord_scale[0] = sort_list[0] + scn_txpose //lowest chord note post inversion
	inv_chord_scale[1] = sort_list[0] + 1 + scn_txpose 
	inv_chord_scale[2] = sort_list[0] + interval1 + scn_txpose 
	inv_chord_scale[3] = sort_list[1] - 1 + scn_txpose 
	inv_chord_scale[4] = sort_list[1] + scn_txpose //2nd lowest chord note post inversion
	inv_chord_scale[5] = sort_list[1] + 1 + scn_txpose 
	inv_chord_scale[6] = sort_list[2] - 1 + scn_txpose 
	inv_chord_scale[7] = sort_list[2] + scn_txpose //3rd lowest chord note post inversion
	inv_chord_scale[8] = sort_list[2] + 1 + scn_txpose 
	inv_chord_scale[9] = sort_list[2] + interval2 + scn_txpose 
	inv_chord_scale[10]= sort_list[3] - 1 + scn_txpose 
	inv_chord_scale[11]= sort_list[3] + scn_txpose //highest chord note post inversion
	
	CopyArray chord_scale, all_chord_scales[chord_scale_slot], 12
	CopyArray inv_chord_scale, all_inv_chord_scales[chord_scale_slot], 12
	
	//LOGGING!!!
	cs=[]
	CopyArray chord_scale, cs, 12 //just for logging here
	CopyArray inv_chord_scale, is, 12 //just for logging here
	//Log {--- Made chord scale for s1}, current_scene+1, { chord }, chord_to_set+1, {---}
	//Log {MADE CHORD SCALE:     [}, (NoteName cs[0]),{-},(NoteName cs[1]),{-},(NoteName cs[2]),{-},(NoteName cs[3]),{-},(NoteName cs[4]),{-},(NoteName cs[5]),{-},(NoteName cs[6]),{-},(NoteName cs[7]),{-},(NoteName cs[8]),{-},(NoteName cs[9]),{-},(NoteName cs[10]),{-},(NoteName cs[11]),{]} 
	//Log {MADE INV CHORD SCALE: [}, (NoteName is[0]),{-},(NoteName is[1]),{-},(NoteName is[2]),{-},(NoteName is[3]),{-},(NoteName is[4]),{-},(NoteName is[5]),{-},(NoteName is[6]),{-},(NoteName is[7]),{-},(NoteName is[8]),{-},(NoteName is[9]),{-},(NoteName is[10]),{-},(NoteName is[11]),{]} 
	//Log {INV CHORD: },(NoteName is[0]), (NoteName is[4]), (NoteName is[7]), (NoteName is[11])
	//Log {-----}
@End

@SetChordScale
	//requires chord_to_set - mostly current chord, except when suggest and creating random chord prog
	chord_scale_slot = (current_scene * 120) + ((chord_to_set) * 15)
	chord_slot = (current_scene * 100) + ((chord_to_set) * 10) 
	CopyArray all_chord_scales[chord_scale_slot], current_chord_scale, 12 
	CopyArray all_inv_chord_scales[chord_scale_slot], curr_inv_chord_scale, 12
	//Log {Chord scale set}
@End

@GetChordFlavour
	chord_flavour=1 //major
	if chord_3rd - chord_root = 3
		chord_flavour=0 //minor
	elseif chord_7th>0 and (chord_7th-chord_root=10) //minor7th
	  chord_flavour=0 //minor
	elseif chord_7th>0 and (chord_7th-chord_root=8) //minor6th
		chord_flavour=0 //minor
	endif
@End

@OnMidiNoteOn
	//# Process incoming midi to be re-harmonized (if not Rec Chords mode)
	//# Log {Midi received on CH: }, MIDIChannel, { note: }, MidiNote
	//# -1Off 0Chord 1Round 2+NonChord 3Bass 4Root 5Third 6Fifth 7thru
	//# Record chords from the channel set 
	//# Log {Note received }, { ch:}, MIDIChannel+1, { }, (NoteName MIDIByte2, YES), { [}, MIDIByte2, {]}, { v:}, MIDIByte3, { vs tpad val }, trigger_pads_val, { Mode: }, mode,  
	if player_mode=0 //thru
        SendMIDIThru 
	elseif mode=3 and  MIDIChannel=player_in_channel // records mode 
		Call @HandleRecordNotes
    elseif player_mode=2 and MIDIChannel=player_in_channel and (MidiNote>=trigger_pads_val) and (MIDINote<=trigger_pads_val+7)
		//# trigger chords mode
		note_in_velo = MIDIVelocity
		Call @TurnOffChordNotes //# can only have one chord note per channel playing at any one time
		chord_change_requested=MidiNote-trigger_pads_val
		Call @HandleChordChange
		chord_slot = (current_scene * 100) + ((current_chord) * 10)	
		current_chord_duration = chord_bank[chord_slot + dur_slot]
		if current_chord_duration>0
			Call @SendOutChordNotes
			if update_held_notes_on_chord_change //held note tracking for update on chord change
				held_chord_notes[player_out_channel] = MIDINote
				held_chord_oct_adj[player_out_channel] = 0
			endif
		endif
    elseif ready_to_rec_pad_vals
        if last_pad=8
            custom_pads[1]=MIDIByte2
            for i = 2 to 8
                custom_pads[i]=MIDIByte2+i-1
            endfor
        elseif last_pad=9
            custom_pads[9]=MIDIByte2
            for i = 10 to 16
                custom_pads[i]=MIDIByte2+i-9
            endfor
        elseif last_pad=10
            custom_pads[17]=MIDIByte2
        endif
        Call @SetupPadsLayoutMidiConfig
        custom_pads_type=0 //# notes
        custom_pads[0] = MIDIChannel
    elseif custom_pads_type=0 and (custom_pads[0] <> -1) and (MIDIChannel=custom_pads[0]) //# pads use notes
        if (MIDIByte2>=custom_pads[1] and MIDIByte2<=custom_pads[8]) 
            for i = 1 to 8
                if MIDIByte2=custom_pads[i]
                    last_pad=i-1
                endif
            endfor
            Call @OnPadDown2
        elseif (MIDIByte2>=custom_pads[9] and MIDIByte2<=custom_pads[16]) 
            for i = 9 to 16
                if MIDIByte2=custom_pads[i]
                    last_pad=i-1
                endif
            endfor
            Call @OnPadDown2 //instead of OnPadDown which is only triggered by touch of GUI pads in Mozaic
            
        elseif (MIDIByte2=custom_pads[17]) //SHIFT
            Call @OnShiftDown2
        endif
    elseif harmonize_notes_in and MidiChannel=player_in_channel and player_mode>0
        Call @TriggerHarmonyNote       
    endif
@End

@TriggerHarmonyNote
    new_note = current_chord_scale[MidiNote%12]-48
    if MidiNote%12=1
        new_note = pedal_tone //# scale root
    elseif MidiNote%12=8
        new_note = pedal_tone+7 //# perfect 5th
    endif
    vel = MIDIVelocity
    octave = Div MidiNote, 12
    new_note=(octave*12) + new_note
    SendMIDINoteOn MidiChannel, new_note, vel
    SetNoteState MIDIChannel, MIDINote, new_note
    if log_harmony_notes
        Call @LogHarmonyNotes
    endif
@End

@TurnOffHarmonyNote
    note_off = GetNoteState MIDIChannel, MIDINote 
    SendMIDINoteOff MidiChannel, note_off, MIDIVelocity 
@End

@LogHarmonyNotes
    log {NoteOn:  CH}, MidiChannel, { Note }, MidiNote, { (}, (NoteName MidiNote), {) converted to Note }, new_note, { (}, (NoteName new_note), {)}
    if in_settings_mode
        LabelPad 12, {IN: }, (NoteName MidiNote), { (}, MidiNote, {) }, { OUT: }, (NoteName new_note), { (}, new_note, {)}
    endif
@End


@SendOutChordNotes
	//# Send out chord notes 
	chord_slot = (current_scene * 100) + ((current_chord) * 10)
	chord_scale_slot = (current_scene * 120) + ((chord_to_set) * 15)
	CopyArray all_inv_chord_scales[chord_scale_slot], curr_inv_chord_scale, 12 //make sure we have current chord notes
	
	note_in_velo = MIDIVelocity // for Humanize Velocity
	if player_mode=2 and harmonize_notes_in=FALSE //trigger mode and not harmonize notes mode
		if current_chord_scale[0]>=0 and current_chord_scale[4]>=0 and current_chord_scale[7]>=0 
			//aka chord_formed we can send chord notes
			index_to_chord_notes=[0,4,7,11]
			num_chrd_notes_to_play=2 // a triad
			if chord_bank[chord_slot + 3] >= 0 //7th note in current chord 
				num_chrd_notes_to_play=3 //a tetrad
			endif
			for i = 0 to num_chrd_notes_to_play  
				Call @HumanizeVelocity
				SendMIDINoteOn player_out_channel, (current_chord_scale[index_to_chord_notes[i]]), velocity
				SetNoteState player_out_channel, i, (current_chord_scale[index_to_chord_notes[i]])
			endfor
		endif
	endif
@End

@TurnOffChordNotes
	for i = 0 to 3
		//# stored in 1st 4 note slots (0-3) on each channel
		if (GetNoteState player_out_channel, i)
			SendMIDINoteOff player_out_channel, (GetNoteState player_out_channel, i), 127, chord_note_off_delay
			SetNoteState player_out_channel, i, FALSE
  		endif
  	endfor
@End

@HandleInversionSetting
	//only call from make chord scale where chord_root, chord_3rd, chord_5th, chord_7th are set
	//handle +/- octaves to chord notes and order by fixed R357 or ascending chord notes order
	chrd_inversion = chord_bank[chord_slot + inv_slot]
	inv_adj_amts=[0,0,0,0] //no inversion
	if chrd_inversion = 1
		inv_adj_amts=[12,0,0,0]
	elseif chrd_inversion = 2
		inv_adj_amts=[12,12,0,0]
	elseif chrd_inversion = 3
		inv_adj_amts=[12,12,12,0]
	elseif chrd_inversion = 4
		if chord_7th > -1
			inv_adj_amts=[12,12,12,12]
		else
			inv_adj_amts=[12,12,12,0]
		endif
	elseif chrd_inversion = -1
		if chord_7th > -1
			inv_adj_amts=[0,0,0,-12]
		else
			inv_adj_amts=[0,0,-12,0]
		endif
	elseif chrd_inversion = -2
		if chord_7th > -1
			inv_adj_amts=[0,0,-12,-12]
		else
			inv_adj_amts=[0,-12,-12,0]
		endif
	elseif chrd_inversion = -3
		if chord_7th > -1
			inv_adj_amts=[0,-12,-12,-12]
		else
			inv_adj_amts=[-12,-12,-12,0]
		endif
	elseif chrd_inversion = -4
		if chord_7th > -1
			inv_adj_amts=[-12,-12,-12,-12]
		else
			inv_adj_amts=[-12,-12,-12,0]
		endif
	endif
	
	//# Re-define chord notes based on inverted status
	//# remove octave added above
	inv_chord_root = chord_root + inv_adj_amts[0]
	inv_chord_3rd = chord_3rd + inv_adj_amts[1]
	inv_chord_5th = chord_5th + inv_adj_amts[2]
	inv_chord_7th= chord_7th + inv_adj_amts[3]
@End

@MakeChordNotesRawOctave
	//# Set variabes chord_root, 3rd, 5th and 7th.
	//# updated to remove octave but maintain ascending note order
	chord_root = chord_root % 12
	chord_3rd = chord_3rd % 12
	if chord_root > chord_3rd
		chord_3rd = chord_3rd + 12
	endif
	chord_5th = chord_5th % 12
	if chord_3rd > chord_5th
		chord_5th = chord_5th + 12
	endif
	if chord_7th >= 0
		chord_7th = chord_7th % 12
		if chord_5th > chord_7th
			chord_7th = chord_7th + 12
		endif
		chord_7th = chord_7th + base_starting_note
	else
		chord_7th = -1
	endif
	chord_root = chord_root + base_starting_note
	chord_3rd = chord_3rd + base_starting_note
	chord_5th = chord_5th + base_starting_note	
@End
	
@HumanizeVelocity
	// #Velocity humanization. requires note_in_velo 
  humanize_velocity = 80 // #50-100 Lower = more variation
  dip_velocity_pct = 60 // #50-100 Reduce velocity by %
	humanize_pct = (Random humanize_velocity, 100 ) / 100
	velocity = RoundUp (note_in_velo * humanize_pct)
	velocity_dipped = RoundUp (velocity * dip_velocity_pct/100)
@End 

@OnMidiNoteOff  
    // #handle selected device pad release
    ready_to_rec_pad_vals=FALSE
    if player_mode=0 //thru
        SendMIDIThru 
	elseif player_mode=2 and MIDIChannel=player_in_channel and (MidiNote>=trigger_pads_val) and (MIDINote<=trigger_pads_val+7)
		//chord mode=trigger mode
		Call @TurnOffChordNotes
		if update_held_notes_on_chord_change
			held_chord_notes[player_out_channel] = -1
			held_chord_oct_adj[player_out_channel] = 0
		endif
    elseif custom_pads_type=0 and (custom_pads[0] <> -1) and (MIDIChannel=custom_pads[0]) //# pads use notes
        if (MIDIByte2>=custom_pads[1] and MIDIByte2<=custom_pads[8])
            for i = 1 to 8
                if MIDIByte2=custom_pads[i]
                    last_pad=i-1
                endif
            endfor
            Call @OnPadUp2
        elseif (MIDIByte2>=custom_pads[9] and MIDIByte2<=custom_pads[16])
            for i = 9 to 16
                if MIDIByte2=custom_pads[i]
                    last_pad=i-1
                endif
            endfor
            Call @OnPadUp2
        elseif (MIDIByte2=custom_pads[17]) //SHIFT
            Call @OnShiftUp2
        endif
    elseif harmonize_notes_in and MidiChannel=player_in_channel and player_mode>0
        Call @TurnOffHarmonyNote
    endif
@End

@HandleRecordNotes
	//Log {HANDLING RECORD NOTES TO CHORD SLOT}
	if (mode = 3) and (rec_chord_note_count <= 3)
  	//# In record mode and chord selected for updating
    //Log {Chord note recieved num: }, rec_chord_note_count
    if rec_chord_note_count = 0
	    //# Recording is happening so reset the current notes
	    chord_slot = (current_scene * 100) + (current_chord * 10)
	    for i = 0 to 3
	    	//Log {RESETTING CHORD SLOT }, chord_slot+i
  	  	chord_bank[chord_slot+i] = -1
    	endfor
    	chord_bank[chord_slot+inv_slot] = 0 //# start new chord with no inv.
    	rec_chord_notes = [-1,-1,-1,-1] //# reset array to empty
    	//Log {Current chord: }, current_chord
    	chrd_to_label = current_chord+8
    	Call @LabelChordPad //# re-label after notes reset
    endif
		
		//# Store recorded chord notes and update chord_bank and label
    rec_chord_notes[rec_chord_note_count] = MIDINote
    CopyArray rec_chord_notes, sort_list
    rec_chord_note_count = rec_chord_note_count + 1
    len_list = rec_chord_note_count
    if len_list > 1
	    Call @SortList
    endif
    CopyArray sort_list, rec_chord_notes
    Call @StoreChordNotes
    chrd_to_label = current_chord+8
    Call @LabelChordPad
    Call @SetupLayout
		Call @UpdateChordsWithDuration
		chord_to_set=current_chord //always except in random gen and suggest
		Call @MakeChordScale
  endif
@End

@StoreChordNotes
	//# Store the recorded notes to the chord slot
  chord_slot = (current_scene * 100) + (current_chord * 10)
  for i = 0 to 3
  	if rec_chord_notes[i] >= 0
	  	chord_bank[chord_slot + i] = rec_chord_notes[i]
	  	//Log {Chord note }, i, { is }, rec_chord_notes[i], { in chord slot}, chord_slot+i
	  else
	  	chord_bank[chord_slot + i] = -1
	  endif
  endfor
	if chord_bank[chord_slot + dur_slot] <= 0 //# Set a default duration
  	chord_bank[chord_slot + dur_slot] = 4
  endif
	Log {NOTES: }, chord_bank[chord_slot], {-}, chord_bank[chord_slot+1], {-}, chord_bank[chord_slot+2], {-}, chord_bank[chord_slot+3]
@End

@ResetScene
  //# Reset scene: Duration, Txpose, Preset, modes for ch's 1-4, out ch's ON1-4, pgm_chg_msg
  scene_bank[last_pad * sc_size] = [-1,6,0,0,0,0,0,0,0,0,0,-1]
  chord_slot = (last_pad * 100)
	for c = 0 to 7
		chord_bank[(current_scene*100) + (c*10)] = [-1, -1, -1, -1, 0, 0, -1]
	endfor
  //reset chord scales
	chord_scale_slot = (current_scene * 120)
	FillArray all_chord_scales[chord_scale_slot], -1, (8*15)
	FillArray all_inv_chord_scales[chord_scale_slot], -1, (8*15)
	Call @SetupLayout
	num_scns_with_dur=last_pad-1 //RND only selects scenes before deleted scn
	num_chrds_with_dur[current_scene]=0 //del scene also deletes chords
  //Log {Scene }, last_pad +1, { reset. All chords for scene reset}
@End

@ResetChord
	chord_slot = (current_scene * 100) + ((last_pad - 8) * 10)
  //# 4 chord notes, duration, inv, bass, pattern_msg 
  chord_bank[chord_slot] = [-1,-1,-1,-1,0,0,-1,-1]
	num_chrds_with_dur[current_scene]=last_pad-8-1
	//reset chord scales
	chord_scale_slot = (current_scene * 120) + ((current_chord) * 15)
	FillArray all_chord_scales[chord_scale_slot], -1, 15
	FillArray all_inv_chord_scales[chord_scale_slot], -1, 15
  //Log {Chord }, last_pad+1, { reset}
  Call @SetupLayout
@End

@CopyPaste
	//# copy paste scenes and chords
	if last_pad <=7
		//Log {Pasting scene to }, current_scene+1 
		LabelPads {Copied Scene }, copied_scene+1, { to Scene }, last_pad+1
		CopyArray scene_bank[copied_scene * sc_size], scene_bank[last_pad * sc_size], sc_size
		CopyArray chord_bank[copied_scene * 100], chord_bank[last_pad * 100], 100
		//# Exit copy paste
		songmode = 1
		mode=0
		Call @UpdateScenesWithDuration
		Call @UpdateChordsWithDuration
		Call @MakeChordScaleForScene
	elseif last_pad >= 8
		//Log {pasting to chord }, last_pad-8
		LabelPads	{Copied S}, copied_scene+1, { Chord }, copied_chord+1, { to }, {S}, current_scene+1, { Chord }, last_pad-7
		chord_slot_from = (copied_scene * 100) + (copied_chord * 10)
		chord_slot_to = (current_scene * 100) + ((last_pad-8) * 10)
		CopyArray chord_bank[chord_slot_from], chord_bank[chord_slot_to], 10
		//# Exit copy paste
		songmode = 2
		mode=0
		Call @UpdateChordsWithDuration
		chord_to_set=current_chord //always except in random gen and suggest
		Call @MakeChordScale
	endif
	copied_scene = -1 //# reset
	copied_chord = -1
	Call @SetupLayout 
@End

@SuggestChord
	//# Make a chord suggestion based on previous chord. Update current chord slot
	chord_slot = (current_scene * 100) + (current_chord * 10) //# chord to update
	suggested_chord_notes=[]
	n1=0 //prev_root
	n2=4 //prev_3rd
	n3=7 //prev_5th
	n4=11 //prev_7th
	d=4 //duration
	i=0 //inversion
	
	if current_scene>0 and current_chord=0 //# use last chord prev_scene
		for x = 0 to 7
			test_slot = ((current_scene-1) * 100) + (x * 10)
			if chord_bank[chord_slot+dur_slot] > 0 //# chord has duration so use it	
				prev_chord_slot=test_slot
			else
			  prev_chord_slot=test_slot
	  	endif
		endfor
		n1=chord_bank[prev_chord_slot]%12
		n2=chord_bank[prev_chord_slot+1]%12
		n3=chord_bank[prev_chord_slot+2]%12
		n4=chord_bank[prev_chord_slot+3]%12
		d=chord_bank[prev_chord_slot+4]
		i=chord_bank[prev_chord_slot+5]%12
	elseif current_chord>0
		prev_chord_slot = ((current_scene) * 100) + ((current_chord-1) * 10)
		n1=chord_bank[prev_chord_slot]%12
		n2=chord_bank[prev_chord_slot+1]%12
		n3=chord_bank[prev_chord_slot+2]%12
		n4=chord_bank[prev_chord_slot+3]%12
		d=chord_bank[prev_chord_slot+4]
		i=chord_bank[prev_chord_slot+5]%12
	endif
	
	CopyArray current_chord_scale, ccs, 14 //use current chord scale to generate new chord shape
	
	//# chord = [note1, note2, note3, note4, duration, inv, bass]
	chord_suggest_bank[0*10]  = [n1,        n2,         n3,         n4,         d,i,n1]
	chord_suggest_bank[1*10]  = [n1,        (n1+2)%12,  n3,         -1,         d,i,n1] //sus2
	chord_suggest_bank[2*10]  = [n1,        (n1+3)%12,  n3,         -1,         d,i,n1] //minor
	chord_suggest_bank[3*10]  = [n1,        (n1+4)%12,  n3,         -1,         d,i,n1] //major
	chord_suggest_bank[4*10]  = [n1,        (n1+5)%12,  n3,         -1,         d,i,n1] //sus4
	chord_suggest_bank[5*10]  = [n1,        (n1+3)%12,  (n1+7)%12,  (n1+10)%12, d,i,n1] //minor7
	chord_suggest_bank[6*10]  = [n1,        (n1+4)%12,  (n1+7)%12,  (n1+11)%12, d,i,n1] //major7
	chord_suggest_bank[7*10]  = [n1,        (n1+4)%12,  (n1+7)%12,  (n1+10)%12, d,i,n1] //dom7
	chord_suggest_bank[8*10]  = [n2,        (n2+4)%12,  (n2+7)%12,  -1,         d,i,n2] //chords 3rd as root
	chord_suggest_bank[9*10]  = [n2,        (n2+3)%12,  (n2+7)%12,  -1,         d,i,n2]
	chord_suggest_bank[10*10] = [n2,        (n2+4)%12,  (n2+7)%12,  (n2+11)%12, d,i,n2]
	chord_suggest_bank[11*10] = [n2,        (n2+3)%12,  (n2+7)%12,  (n2+10)%12, d,i,n2]
	chord_suggest_bank[12*10] = [n3,        (n3+4)%12,  (n3+7)%12,  -1,         d,i,n3] //chords 5th as root
	chord_suggest_bank[13*10] = [n3,        (n3+3)%12,  (n3+7)%12,  -1,         d,i,n3]
	chord_suggest_bank[14*10] = [n3,        (n3+4)%12,  (n3+7)%12,  (n3+11)%12, d,i,n3]
	chord_suggest_bank[15*10] = [n3,        (n3+3)%12,  (n3+7)%12,  (n3+10)%12, d,i,n3]
	chord_suggest_bank[16*10] = [(n1+9)%12, (n1+12)%12, (n2+12)%12, -1,         d,i,(n1+9)%12] //chords root-3rd 
	
	//# Update the current chord with suggested notes
	CopyArray chord_suggest_bank[chrd_sugg*10], chord_bank[chord_slot], 7
	chrd_to_label = current_chord+8
	Call @LabelChordPad		
@End

@SetupKnobset99
	knob_set = 99
	SetKnobValue 0, TranslateScale player_in_channel, 0, 14, 0, 127
    SetKnobValue 1, TranslateScale player_out_channel, 0, 14, 0, 127
    SetKnobValue 2, TranslateScale player_mode, 0, 2, 0, 127
    if harmonize_notes_in   
        SetKnobValue 3, TranslateScale pedal_tone, 0, 11, 0, 127
    else
        SetKnobValue 3, TranslateScale trigger_pads_val, 0, 72, 0, 127
    endif
	Call @LabelSettingsKnobs
@End
@KnobChangeSet99 //settings knobs
    if last_knob = 0
        val = Round TranslateScale (GetKnobValue 0), 0, 127, 0, 14
        if val <> player_in_channel 	
            player_in_channel = val
            Call @LabelSettingsKnobs
        endif
    elseif last_knob = 1
        val = Round TranslateScale (GetKnobValue 1), 0, 127, 0, 14
        if val <> player_out_channel 	
            player_out_channel = val
            Call @LabelSettingsKnobs
        endif
    elseif last_knob = 2
        val = Round TranslateScale (GetKnobValue 2), 0, 127, 0, 2
        if val <> player_mode 	
            player_mode = val
            Call @LabelSettingsKnobs
            Call @SetupSettingsLayout
            if player_mode=0
                LabelPads {Genochord is off. No chords played or triggered}
            elseif player_mode=1
                LabelPads {Chords play as sequenced on Out channel }, player_out_channel+1
            else
                LabelPads {Trigger chords with notes from }, (NoteName trigger_pads_val, YES), { to }, (NoteName trigger_pads_val+7, YES), { on channel }, player_in_channel+1, { (*CH aka }, player_in_channel, { )} 
            endif
        endif
    elseif last_knob = 3 and harmonize_notes_in
        val = Round TranslateScale (GetKnobValue 3), 0, 127, 0, 11
        if val <> pedal_tone
            pedal_tone = val
            LabelPad 11, {Pedal: }, (NoteName pedal_tone)
            Call @LabelSettingsKnobs
            LabelPad 15, {TRIGGER CHORDS:         }, (NoteName trigger_pads_val, YES), {-}, (NoteName trigger_pads_val+7, YES)
        endif
    elseif last_knob = 3 and not harmonize_notes_in
        val = Round TranslateScale (GetKnobValue 3), 0, 127, 0, 72
        if val <> trigger_pads_val
            trigger_pads_val = val
            Call @LabelSettingsKnobs
            LabelPad 15, {TRIGGER CHORDS:         }, (NoteName trigger_pads_val, YES), {-}, (NoteName trigger_pads_val+7, YES)
            LabelPads {Trigger chords with notes from }, (NoteName trigger_pads_val, YES), { to }, (NoteName trigger_pads_val+7, YES), { on channel }, player_in_channel+1, { (*CH aka }, player_in_channel, { )} 
        endif
    endif
@End
@LabelSettingsKnobs
    LabelKnob 0, {In CH}, player_in_channel+1
    LabelKnob 1, {Out CH}, player_out_channel+1
    if player_mode=0
        LabelKnob 2, {THRU}
    elseif player_mode=1
        LabelKnob 2, {PLAY}
    else
        LabelKnob 2, {TRIGGER}
    endif
    if harmonize_notes_in
        LabelKnob 3, {Pedal }, (NoteName pedal_tone)
    else
        LabelKnob 3, {Note }, trigger_pads_val
    endif
    LabelKnobs {Midi In/Out + Mode}
	LabelPads {GENOCHORD : [ SETTINGS ]}
@End

@SetupKnobset0
	//# Scene settings
	knob_set = 0
	LabelKnobs {Scene }, current_scene+1, { setup}
	scn_duration = scene_bank[current_scene * sc_size]
	scn_txpose = scene_bank[(current_scene * sc_size) + sc_txp_slot]
	scn_preset = scene_bank[(current_scene * sc_size) + sc_preset_slot]
	LabelKnob 0, {Duration}
	LabelKnob 1, {Transpose}
	LabelKnob 2, {Preset }, scn_preset
	if txpose_w_circle_fifths
		LabelKnob 3, {TXP CoF} 
	else
		LabelKnob 3, {TXP ST}
	endif
	SetKnobValue 0, TranslateScale scn_duration, 0, 32, 0, 127
	SetKnobValue 1, TranslateScale scn_txpose, 0, 12, 0, 127
	SetKnobValue 2, TranslateScale scn_preset, 1, num_sc_presets, 0, 127
	SetKnobValue 3, TranslateScale txpose_w_circle_fifths, 0, 1, 0, 127 
@End
@KnobChangeSet0
	//# scene settings
	if last_knob = 0
	  scn_duration = Round TranslateScale (GetKnobValue 0), 0, 127, 0, 32
	  if scn_duration <> scene_bank[current_scene * sc_size] 	
		    scene_bank[current_scene * sc_size] = scn_duration
	  	    LabelKnob 0 , {Dur }, scn_duration
			Call @UpdateScenesWithDuration
	  endif
    endif
  if last_knob = 1
	    scn_txpose = Round TranslateScale (GetKnobValue 1), 0, 127, 0, 12
	    if scn_txpose <> scene_bank[(current_scene * sc_size) + sc_txp_slot] 	
		    scene_bank[(current_scene * sc_size) + sc_txp_slot] = scn_txpose
		    Call @SetupLayout //# re-label all chord pads
			Call @MakeChordScaleForScene
		endif
  endif
  if last_knob = 2 and pad_is_down
	    scn_preset = Round TranslateScale (GetKnobValue 2), 0, 127, 1, num_sc_presets
	    scene_bank[(current_scene * sc_size) + sc_preset_slot] = scn_preset
	    LabelKnob 2, scn_preset
  	    Call @ChangeScenePreset
		Call @UpdateScenesWithDuration
    elseif last_knob = 2 and not pad_is_down
        LabelPads {Hold SCENE PAD down to change preset}
	endif
  if last_knob = 3
	  txpose_val = Round TranslateScale (GetKnobValue 3), 0, 127, 0, 1
		if txpose_val <> txpose_w_circle_fifths
			txpose_w_circle_fifths = txpose_val
			Call @TransposeCalcArrays
			Call @SetupLayout
			Call @SetupKnobset0
		endif
  endif
  scn_to_label = current_scene
  Call @LabelScenePad
@End

@SetupKnobset1
	//# Chord settings
	knob_set = 1
	LabelKnobs {Chord }, current_chord+1, { setup}
	chord_slot = (current_scene * 100) + ((current_chord) * 10)
	chrd_duration = chord_bank[chord_slot + dur_slot]
	chrd_inversion = chord_bank[chord_slot + inv_slot]
	chrd_sugg = chord_bank[chord_slot + sugg_slot]
	if mode = 3
		LabelKnob 1, {REC CH }, player_in_channel + 1
		SetKnobValue 1, TranslateScale player_in_channel, 0, 14, 0, 127
	else
		LabelKnob 1, {Suggest}, chrd_sugg
		SetKnobValue 1, TranslateScale chrd_sugg, 0, 16, 0, 127
	endif
	LabelKnob 0, {Duration}	
	LabelKnob 2, {Inv }, chrd_inversion
	LabelKnob 3, { }
	SetKnobValue 0, TranslateScale chrd_duration, 0, 31, 0, 127
	SetKnobValue 2, TranslateScale chrd_inversion, -4, 4, 0, 127
	SetKnobValue 3, 0
@End
@KnobChangeSet1
//# chord settings
	chord_slot = (current_scene * 100) + ((current_chord) * 10)
	chord_to_set=current_chord
	if last_knob = 0
	  chrd_duration = (Round TranslateScale (GetKnobValue 0), 0, 127, 0, 31)+1
	  if chrd_duration <> chord_bank[chord_slot + dur_slot] 
		  chord_bank[chord_slot + dur_slot] = chrd_duration
		  dur_bars = Div chrd_duration, 4
			dur_beats = (chrd_duration % HostBeatsPerMeasure) * (100/HostBeatsPerMeasure)
	  	LabelKnob 0 , {Dur }, dur_bars, {.}, dur_beats
			Call @UpdateChordsWithDuration
        endif
  	endif
    if last_knob = 1 and mode <> 3
        chrd_sugg = Round TranslateScale (GetKnobValue 1), 0, 127, 0, 16
        if chrd_sugg <> chord_bank[chord_slot + sugg_slot] 
            chord_bank[chord_slot + sugg_slot] = chrd_sugg
            LabelKnob 1, {Suggest}, chrd_sugg
            Call @SuggestChord
            Call @MakeChordScale
        endif
    endif
    if last_knob = 2
        chrd_inversion = Round TranslateScale (GetKnobValue 2), 0, 127, -4, 4
        if chrd_inversion <> chord_bank[chord_slot + inv_slot] 
            chord_bank[chord_slot + inv_slot] = chrd_inversion
            LabelKnob 2, {Inv }, chrd_inversion
            Call @MakeChordScale
        endif 
    endif
    chrd_to_label = current_chord+8
    Call @LabelChordPad
@End
@UpdateScenesWithDuration
	for s = 0 to 7 //Update number of scenes with duration for random selection
		if scene_bank[s * sc_size] > 0
			num_scns_with_dur=s
		else
		  Exit
		endif	
	endfor
@End
@UpdateChordsWithDuration
	for c = 0 to 7 //Update number of chords in scene with duration for random selection
		if chord_bank[(current_scene * 100) + (c * 10) + dur_slot] > 0
			num_chrds_with_dur[current_scene]=c
		else
		  Exit
		endif	
	endfor
@End

@SetupKnobset2
	//# Chord select settings
	knob_set = 2
	chord_slot = (current_scene * 100) + ((current_chord) * 10)
	LabelKnobs {Selecting }, {S}, current_scene+1, { Chord: }, current_chord+1
	
	//# if new chord default values from FillArray used here
	slct_chord_root = chord_bank[chord_slot] % 12
	slct_chord_inversion = chord_bank[chord_slot + inv_slot]
	
	//# Knob setup
	LabelKnob 0, {Root }, (NoteName slct_chord_root)
	LabelKnob 1, {Type}
	LabelKnob 2, {Inv }, slct_chord_inversion 
	LabelKnob 3, { }
	SetKnobValue 0, TranslateScale slct_chord_root, 0, 11, 0, 127
	SetKnobValue 1, TranslateScale slct_chord_type, 0, num_chord_types-1, 0, 127
	SetKnobValue 2, TranslateScale slct_chord_inversion, -4, 4, 0, 127
	SetKnobValue 3, 0
	//# prevent updating values not changed
	root_updated = FALSE
	type_updated = FALSE
	inv_updated = FALSE
@End
@KnobChangeSet2
	inv_updated = FALSE
	chord_to_set = current_chord
	if last_knob = 0
	    val = Round TranslateScale (GetKnobValue 0), 0, 127, 0, 11
  	    if val <> slct_chord_root
			slct_chord_root = val
			LabelKnob last_knob, {Root }, (NoteName slct_chord_root)
  		    root_updated = TRUE
			Call @SaveSelectedChordPad
		endif
  elseif last_knob = 1
  	val = Round TranslateScale (GetKnobValue 1), 0, 127, 0, num_chord_types-1
		if val <> slct_chord_type
			slct_chord_type = val
            if slct_chord_type = 0
                LabelKnob 1, {Major}
            elseif slct_chord_type = 1
                LabelKnob 1, {Minor}
            elseif slct_chord_type = 2
                LabelKnob 1, {Diminished}
            elseif slct_chord_type = 3
                LabelKnob 1, {Augmented}
            elseif slct_chord_type = 4
                LabelKnob 1, {Sus2}
            elseif slct_chord_type = 5
                LabelKnob 1, {Sus4}
            elseif slct_chord_type = 6
                LabelKnob 1, {Minor 6th}
            elseif slct_chord_type = 7
                LabelKnob 1, {Major 6th}
            elseif slct_chord_type = 8
                LabelKnob 1, {Minor 7th}
            elseif slct_chord_type = 9
                LabelKnob 1, {Dom 7th}
            elseif slct_chord_type = 10
                LabelKnob 1, {Major 7th}
            endif
            type_updated = TRUE
	  	    Call @SaveSelectedChordPad
		endif
  elseif last_knob = 2
  	val = Round TranslateScale (GetKnobValue 2), 0, 127, -4, 4
	  if val <> slct_chord_inversion
			slct_chord_inversion = val
			LabelKnob last_knob, {Inv: }, slct_chord_inversion
	  	inv_updated = TRUE
	  	Call @SaveSelectedChordPad
		endif
	endif
@End

@SetupKnobset3
	// Setup custom genochord knobs settings
	knob_set = 3
	LabelPads {[ SETUP GENOCHORD KNOBS ] - Set channel then hold pad & wiggle knob left AND right}
	LabelKnobs {KNOB SETTINGS}
	if custom_knobs[0] = -1
		LabelKnob 0, {Not in use}
	else
		LabelKnob 0, {Chan:}, custom_knobs[0]+1
	endif
	if kntrl_knob_type=0
		LabelKnob 1, {Type: ENC} 
        LabelKnob 3, {Rate }, (knob_scale_turn/10)
        SetKnobValue 3, TranslateScale knob_scale_turn, 2, 18, 0, 127
	else 
		LabelKnob 1, {Type: POT}
        LabelKnob 3, { }
        ColorPad 6, 0
        ColorPad 7, 0
	endif
	LabelKnob 2, Round enc_test_val
	SetKnobValue 0, TranslateScale custom_knobs[0], -1, 14, 0, 127
	SetKnobValue 1, TranslateScale kntrl_knob_type, 0, 1, 0, 127
	SetKnobValue 2, TranslateScale enc_test_val, 0, 127, 0, 127
@End

@KnobChangeSet3
	if last_knob = 1 // KNOB TYPE
		val = Round TranslateScale (GetKnobValue 1), 0, 127, 0, 1 // knob type
		kntrl_knob_type = val
        if kntrl_knob_type=1
            kntrl_output_relenc=FALSE
        endif
    elseif last_knob = 2 // test encoder 
        val = Round TranslateScale (GetKnobValue 2), 0, 127, 0, 127 // test knob type
        enc_test_val = val
    elseif last_knob = 3 // knob_scale_turn
        val = Round TranslateScale (GetKnobValue 3), 0, 127, 2, 18 // knob_scale_turn
        knob_scale_turn = val
	endif
	Call @SetupPadsLayoutMidiConfig
@End

@SetupPadsLayoutMidiConfig
    k4=0
    p16=0
    if custom_knobs[0] > -1
        k4=3
    endif
    if custom_pads[0] > -1
        p16=3
    endif
    midi_learn_pad_cols=[k4,k4,k4,k4, 0,0,0,0, p16,p16,p16,p16, 0,0,0,0]
    for i = 0 to 15
		LabelPad i, { }
		ColorPad i, midi_learn_pad_cols[i]
        LatchPad i, NO
	endfor
	for i = 4 to 7
		ColorPad i, 0
	endfor
    if invert_enc_dir
        ColorPad 6, 1
        ColorPad 7, 1
    endif
	if custom_knobs[0] = -1 //custom knobs not in use
		LabelPad 0, { KNOB    }, {    TOP L    }, {  -----  }
		LabelPad 1, { KNOB    }, {    TOP R    }, {  -----  }
		LabelPad 2, { KNOB    }, {    LOW L    }, {  -----  }
		LabelPad 3, { KNOB    }, {    LOW R    }, {  -----  }
		LabelPad 4, { }
		LabelPad 5, { }
		LabelPad 6, { }
		LabelPad 7, { }
	else
		LabelPad 0, { KNOB    }, {    TOP L    }, { cc#}, custom_knobs[1]
		LabelPad 1, { KNOB    }, {    TOP R    }, { cc#}, custom_knobs[2]
		LabelPad 2, { KNOB    }, {    LOW L    }, { cc#}, custom_knobs[3]
		LabelPad 3, { KNOB    }, {    LOW R    }, { cc#}, custom_knobs[4]
		LabelPad 4, { }
		LabelPad 5, { }
        if kntrl_knob_type=0 //encoder
    	    if invert_enc_dir
            	LabelPad 6, {Invert YES}
                LabelPad 7, enc_inc_dec_vals[1], { / }, enc_inc_dec_vals[0]
            else    
                LabelPad 6, {Invert NO}
                LabelPad 7, enc_inc_dec_vals[0], { / }, enc_inc_dec_vals[1]
            endif
        else //regular cc 
            LabelPad 6, { }
            LabelPad 7, { }
        endif
	endif
    if custom_pads[0] = -1
        LabelPad 8, {  PADS1-8   }
        LabelPad 9, {  PADS9-16  }
        LabelPad 10, {  SHIFT  }
    elseif custom_pads_type=0
        LabelPad 8, {  PADS1-8   }, custom_pads[1], {-}, custom_pads[8]
        LabelPad 9, {  PADS9-16  }, custom_pads[9], {-}, custom_pads[16]
        LabelPad 10, {  SHIFT  }, custom_pads[17]
        LabelPad 11, {Notes on Ch}, custom_pads[0]+1
    elseif custom_pads_type=1
        LabelPad 8, {  PADS1-8   }, custom_pads[1], {-}, custom_pads[8]
        LabelPad 9, {  PADS9-16  }, custom_pads[9], {-}, custom_pads[16]
        LabelPad 10, {  SHIFT  }, custom_pads[17]
        LabelPad 11, {CCs on Ch}, custom_pads[0]+1, { CC}
    endif
    if kntrl_knob_type=0
        if kntrl_output_relenc
           LabelPad 5, {Output: REL. ENC.}
            ColorPad 5, 3
        else
            LabelPad 5, {Output: CONT. ABS.}
            ColorPad 5, 4
        endif
        LabelPad 13, { }
        ColorPad 13, 0
    else 
        LabelPad 5, { }
        ColorPad 5, 0
        if send_feedback_to_pots
            LabelPad 13, {Send feedabck to knobs on}
            ColorPad 13, 3
        else 
            ColorPad 13, 1
            LabelPad 13, {Send feedabck to knobs off}
        endif
    endif
	LabelPad 15, {Settings...}
    Call @SetupKnobset3
@End

@PadDownMidiLearn
	if last_pad<=3
		ready_to_rec_knob_vals=TRUE
		ColorPad 4, 2
		LabelPad 4, {____x____}, { turn encoder }
    elseif last_pad=6 and (custom_knobs[0]>-1) and kntrl_knob_type=0
        invert_enc_dir = not invert_enc_dir
    elseif last_pad=5 and kntrl_knob_type=0
        kntrl_output_relenc = not kntrl_output_relenc
        Call @SetupPadsLayoutMidiConfig
    elseif last_pad=8 
        //configure pads 1-8
        ready_to_rec_pad_vals=TRUE
        LabelPad 11, {____x____}, { Press Pad1 }
        ColorPad 11, 2
    elseif last_pad=9 
        //configure pads 9-16
        ready_to_rec_pad_vals=TRUE
        LabelPad 11, {____x____}, { Press Pad9 }
        ColorPad 11, 2
    elseif last_pad=10
        //configure Shift
        ready_to_rec_pad_vals=TRUE
        LabelPad 11, {____x____}, { Press Shift Pad }
        ColorPad 11, 2
    elseif last_pad=13
        send_feedback_to_pots = not send_feedback_to_pots
	elseif last_pad=15
        mode=0
        Call @SetupSettingsLayout
    endif
@End

@SetupKnobset5
    //# Harmony keyboard
    knob_set = 5
	LabelPads {[ HARMONY KEYBOARD ] - Trigger chord notes over 4 octaves}
	LabelKnobs {KEYBOARD SETTINGS}
    not_in_use=0
    SetKnobValue 0, TranslateScale hmny_kybd_out_ch, 0, 15, 0, 127
    LabelKnob 0, {Out CH }, hmny_kybd_out_ch+1
    for i = 1 to 3
        SetKnobValue i, TranslateScale not_in_use, 0, 15, 0, 127
        LabelKnob i, { }
    endfor 
@End

@KnobChangeSet5
    //# Harmony keyboard
    knob_set = 5
	if last_knob = 0 and not pad_is_down // OUT CH
		val = Round TranslateScale (GetKnobValue 0), 0, 127, 0, 15 // OUT CH
        if val <> hmny_kybd_out_ch
            hmny_kybd_out_ch = val
            LabelKnob 0, {Out CH }, hmny_kybd_out_ch+1
            if val = player_out_channel
                LabelKnobs {Not allowed}
            else    
                LabelKnobs {KEYBOARD SETTINGS}
            endif
        endif
    elseif last_knob = 0 and HostRunning
        LabelKnobs {RELEASE NOTES FIRST}
	endif
@End

@SetUpHarmonyKeyboard
    hmny_kybd_pad_cols = [4,0,0,0, 4,0,0,0, 4,0,0,0, 4,0,0,0]
    hmny_kybd_pad_nums = [60,64,67,71, 72,76,79,83, 36,40,43,47, 48,52,55,59]
    n1 = curr_inv_chord_scale[0]
    n2 = curr_inv_chord_scale[4]
    n3 = curr_inv_chord_scale[7]
    n4 = curr_inv_chord_scale[11]
    cnotes = [n1,n2,n3,n4, n1,n2,n3,n4, n1,n2,n3,n4, n1,n2,n3,n4]
    for i = 0 to 15
        ColorPad i, hmny_kybd_pad_cols[i]
        LabelPad i, NoteName cnotes[i], YES
        LatchPad i, NO
    endfor
@End

@PadDownHarmonyKeyboard
    FlashPad last_pad
    if LastPadVelocity<64
        note_in_velo = 100
    else
        note_in_velo = LastPadVelocity
    endif
    midi_note = hmny_kybd_pad_nums[last_pad]
    note_in = midi_note%12
    oct_in=Div midi_note, 12
    oct_out=(oct_in*12)-48
    chrd_note_to_play=0
    chrd_note_to_play = curr_inv_chord_scale[note_in]
    if chrd_note_to_play > 0
        note_out = oct_out + chrd_note_to_play
        SendMIDINoteOn hmny_kybd_out_ch, note_out, note_in_velo 
        hmny_kybd_pad_notes_store[last_pad] = note_out 
        //# Log {Played CH }, hmny_kybd_out_ch+1, { - }, note_out, { - }, note_in_velo, { pad nums }  
    endif
@End

@PadUpHarmonyKeyboard
    //# log {PAD UP CH }, hmny_kybd_out_ch, { pad nums }, hmny_kybd_pad_nums[last_pad] 
    if hmny_kybd_pad_notes_store[last_pad]
        SendMIDINoteOff hmny_kybd_out_ch, hmny_kybd_pad_notes_store[last_pad], 127
        hmny_kybd_pad_notes_store[last_pad] = FALSE
        Log {OFF CH }, hmny_kybd_out_ch+1, { - }, note_out, { - }, note_in_velo  
    endif
@End


@SetupKnobset6
	//# Chord construct settings
	knob_set = 6
	chord_slot = (current_scene * 100) + ((current_chord) * 10)
	LabelKnobs {Construct }, {S}, current_scene+1, { Chord: }, current_chord+1
	
	//# if new chord default values from FillArray used here
	constructed_root = chord_bank[chord_slot] % 12
	root_3rd_interval = chord_bank[chord_slot+1] - chord_bank[chord_slot]
	root_5th_interval = chord_bank[chord_slot+2] - chord_bank[chord_slot]
	root_7th_interval = chord_bank[chord_slot+3] - chord_bank[chord_slot]
	
	//# work out what knob value to assign knobs on selection on new chord pad
	if root_3rd_interval = 3
		constructed_3rd = 1
	elseif (root_3rd_interval = 4)
		constructed_3rd = 2
	elseif (root_3rd_interval > 4)
		constructed_3rd = 3
	else
		constructed_3rd = 0
	endif
	
	if root_5th_interval=7
		constructed_5th = 1
	elseif root_5th_interval > 7
		constructed_5th = 2
	elseif (root_5th_interval < 7)
		constructed_5th = 0
	endif
	
	if root_7th_interval = 8
		constructed_7th = 1
	elseif (root_7th_interval = 9)
		constructed_7th = 2
	elseif (root_7th_interval = 10)
		constructed_7th = 3
	elseif (root_7th_interval = 11)
		constructed_7th = 4
	elseif (chord_bank[chord_slot+3] < 0)
		constructed_7th = 0
	else
		constructed_7th = 0
	endif
	
	//# Knob setup - Labelling
	LabelKnob 0, {Root }, (NoteName constructed_root)
	Call @LabelConstructedChord
	SetKnobValue 0, TranslateScale constructed_root, 0, 11, 0, 127
	SetKnobValue 1, TranslateScale constructed_3rd, 0, 3, 0, 127
	SetKnobValue 2, TranslateScale constructed_5th, 0, 2, 0, 127
	SetKnobValue 3, TranslateScale constructed_7th, 0, 4, 0, 127
@End
@KnobChangeSet6
	chord_to_set = current_chord //required for @SaveConstructedChordPad
	if last_knob = 0
	    val = Round TranslateScale (GetKnobValue 0), 0, 127, 0, 11
  	    if val <> constructed_root
			constructed_root = val
			LabelKnob 0, {Root }, (NoteName constructed_root)
  		    Call @SaveConstructedChordPad
		endif
    elseif last_knob = 1
  	    val = Round TranslateScale (GetKnobValue 1), 0, 127, 0, 3
  	    if val <> constructed_3rd
			constructed_3rd = val
			Call @LabelConstructedChord
  		    Call @SaveConstructedChordPad
		endif
  elseif last_knob = 2
  	    val = Round TranslateScale (GetKnobValue 2), 0, 127, 0, 2
	    if val <> constructed_5th
			constructed_5th = val
			Call @LabelConstructedChord
	  	    Call @SaveConstructedChordPad
		endif
  elseif last_knob = 3
	    val = Round TranslateScale (GetKnobValue 3), 0, 127, 0, 4
  	    if val <> constructed_7th
			constructed_7th = val
			Call @LabelConstructedChord
  		    Call @SaveConstructedChordPad
		endif	
	endif
@End
@LabelConstructedChord
	if constructed_3rd = 0
		LabelKnob 1, {sus2}
	elseif constructed_3rd = 1
		LabelKnob 1, {min3 (b3)}
	elseif constructed_3rd = 2
		LabelKnob 1, {maj3}
	elseif constructed_3rd = 3
		LabelKnob 1, {sus4}
	endif
	if constructed_5th = 0
  	LabelKnob 2, {dim (b5)}
  elseif constructed_5th = 1
  	LabelKnob 2, {P5}
  elseif constructed_5th = 2
  	LabelKnob 2, {Aug (#5)}
  endif
	if constructed_7th = 0
  	LabelKnob 3, {None}
  elseif constructed_7th = 1
  	LabelKnob 3, {Min6 (b6)}
 	elseif constructed_7th = 2
  	LabelKnob 3, {Maj6}
  elseif constructed_7th = 3
 		LabelKnob 3, {Min7 (b7)}
 	elseif constructed_7th = 4
 		LabelKnob 3, {Maj7}
  endif
@End

@UpdateCurrentKnobset
	if knob_set = 0 
		Call @SetupKnobset0 //# scene settings
	elseif knob_set = 1
		Call @SetupKnobset1 //# chord settings
	elseif knob_set = 2
		Call @SetupKnobset2	//# CHORD select
	elseif knob_set = 6
		Call @SetupKnobset6	//# CHORD construct
    elseif knob_set = 3
		Call @SetupKnobset3	//# MIDI knob config
	endif
	if in_settings_mode
        Call @SetupKnobset99 //settings knobs
	endif
@End

@OnKnobChange
    last_knob=LastKnob
	Call @OnKnobChange2
    if (kntrl_knob_type <> 0) and send_feedback_to_pots
        //# update knobs when manual touch control is used 
        Call @SendKnobChangeSysex
    endif
@End

@OnKnobChange2
	if knob_set = 0 
		Call @KnobChangeSet0 //# scene settings
	elseif knob_set = 1
		Call @KnobChangeSet1 //# chord settings
	elseif knob_set = 2
		Call @KnobChangeSet2	//# CHORD select
	elseif knob_set = 6
		Call @KnobChangeSet6	//# CHORD construct
    elseif knob_set = 3
        Call @KnobChangeSet3 //# Midi knob config
    elseif knob_set = 5
        Call @KnobChangeSet5 //# harmony keyboard
	elseif knob_set = 99 //settings layout
		Call @KnobChangeSet99 
	endif 
    if (kntrl_knob_type <> 0) and send_feedback_to_pots
        Call @UpdateOtherKnobsIfRequired
    endif
@End 

@OnShiftDown
  Call @OnShiftDown2 //simply to allow midi note in simulation of SHIFT Note16 any channel
@End	

@OnShiftDown2
	shift_is_down=TRUE
	if in_settings_mode
		in_settings_mode = FALSE
		LabelPads {[ GENOCHORD ]  Scene: }, current_scene+1, { Chord: }, current_chord+1
		if (mode >= 1)
			mode = 0
			Call @HandleModeChange
		endif		
		Call @SetupLayout
		Call @OnPadDown_KnobSetSelect
	else
		Call @SetupSettingsLayout
	endif
@End

@OnShiftUp
  Call @OnShiftUp2
@End

@OnShiftUp2
  shift_is_down=FALSE
@End

@SetupSettingsLayout
	// Mode selection for Knobs n Pads
	in_settings_mode = TRUE
	LabelPads {GENOCHORD SETTINGS:   (shift to exit)}
	for i = 0 to 15
		ColorPad i, 6
		LabelPad i, { } //# empty label to overwrite chord info
		LatchPad i, NO 
	endfor
    kc_col=2
    if custom_knobs[0]>=0
		kc_col=3
	endif
    tc_col=0
    if player_mode=2
        tc_col=3
    endif
    hni=0
    if harmonize_notes_in
        hni=3
    endif
    settings_pad_cols=[8,4,7,7,7,0,4,1, kc_col,4,hni,0,0,0,1,tc_col]
	if (songmode = 0)
		LabelPad 0, {PLAYSONG: Active }
	elseif (songmode = 1)
		LabelPad 0, {PLAYSONG: Scene locked}
	elseif (songmode = 2)
		LabelPad 0, {PLAYSONG: Chord locked}
	else
		LabelPad 0, {PLAYSONG: Disabled}
	endif	
	LabelPad 1, {SCENES}
	LabelPad 2, {+CHORDS: Select}
	LabelPad 3, {+CHORDS: Construct}
	LabelPad 4, {+CHORDS: Record}
	LabelPad 5, {GENERATE CHORD PROG.}
	if last_pad<=7 //# copy scene or chord
		LabelPad 6, {COPY/PASTE }, {SCENE }, current_scene+1
		copy_mode=0
	else
		LabelPad 6, {COPY/PASTE }, {CHORD }, current_chord+1
		copy_mode=1 
	endif
	LabelPad 7, {DELETE  }
    LabelPad 8, {MIDI LEARN}
    LabelPad 9, {HARMONY KEYBOARD}
    if harmonize_notes_in
        LabelPad 10, {CHORDS MUTED. HARMONY MODE ON}
        LabelPad 11, {Pedal: }, NoteName pedal_tone
        if log_harmony_notes
            LabelPad 12, { }
        else
            LabelPad 12, {Log harmony notes?}
        endif
    else
        LabelPad 10, {HARMONIZE NOTES IN?}
        LabelPad 11, { }
        LabelPad 12, { }
    endif
    LabelPad 13, { }
    LabelPad 14, { ALL NOTES OFF }
    if player_mode=0
    	LabelPad 15, {Midi Thru}
    elseif player_mode=1
    	LabelPad 15, {CHORDS SEQUENCED BY SCENES}
    elseif player_mode=2
    	LabelPad 15, {TRIGGER CHORDS:         }, (NoteName trigger_pads_val, YES), {-}, (NoteName trigger_pads_val+7, YES)
    endif
	if (mode>=1 and mode<=3)
		LatchPad mode+1, YES //#shifted +Chords in menu
		settings_pad_cols[mode+1]=8
	endif
	for i = 0 to 15
		ColorPad i, settings_pad_cols[i]
		if settings_pad_cols[i]=8
			LatchPad i, YES
		endif
	endfor
	Call @UpdateCurrentKnobset
@End

@OnTimer
	//generate chord progression for current scene
	if timer_type=1
		generate_random_chord=TRUE
		if current_chord_scale[0]>=0 and current_chord_scale[4]>=0 and current_chord_scale[7]>=0
			new_root_choices = [current_chord_scale[0], current_chord_scale[4], current_chord_scale[5], current_chord_scale[7]]
		else
		new_root_choices = [0,4,5,7]
		endif
		len_new_root_choices=2
		new_chord_type_choices=[0,1,4,5,6,7,8,9,10]
		len_new_type_choices=8
		for rc = 0 to 7
			chord_to_set=rc //required for SaveContructedChordPad
			//Call @SaveConstructedChordPad
			Call @SaveSelectedChordPad
			Call @MakeChordScale
			Call @SetChordScale //set the chord scale to the newly created chord to help with suggesting next 
			new_root_choices = [current_chord_scale[0], current_chord_scale[4], current_chord_scale[5], current_chord_scale[7]]
		endfor
		in_settings_mode = FALSE
		mode = 0
		knob_set = 1
		Call @SetupLayout
		LabelPads {RANDOM CHORD PROGRESSION CREATED FOR SCENE }, current_scene+1
		StopTimer
		generate_random_chord=FALSE
	endif
@End

@SortList
  //# set list to sort to sort_list and len_list to # items is your list
  //Log {List to sort }, sort_list[0], sort_list[1], sort_list[2], sort_list[3]
  changed = 1
  while (changed = 1)
    changed = 0
    for i = 0 to len_list - 2
	  if sort_list[i] > sort_list[i+1]
	     changed = 1
        tmp = sort_list[i]
        sort_list[i] = sort_list[i+1]
        sort_list[i+1] = tmp
      endif
    endfor
  endwhile
  //Log {Sorted List: }, sort_list[0], sort_list[1], sort_list[2], sort_list[3]
@End

@LabelScenePad
	//# Set scn_to_label var before calling
	sc_dur = scene_bank[scn_to_label * sc_size]
	sc_txp = txpose_labels[scene_bank[(scn_to_label * sc_size) + sc_txp_slot]]
	sc_preset = scene_bank[(scn_to_label * sc_size) + sc_preset_slot]
	sc_txpm = sc_txp - 3
	if sc_txpm < 0
		sc_txpm = sc_txpm + 12
	endif
	if txpose_w_circle_fifths
		LabelPad scn_to_label, {S}, scn_to_label+1, { [}, sc_dur, { bars]}, {    }, (NoteName sc_txp), {/}, (NoteName sc_txpm), {m(}, txpose_array[scene_bank[(scn_to_label * sc_size) + sc_txp_slot]], {st) }
	else
		LabelPad scn_to_label, {S}, scn_to_label+1, { [}, sc_dur, { bars]}, {    Txpose: }, txpose_array[scene_bank[(scn_to_label * sc_size) + sc_txp_slot]], {st }
	endif
@End

@LabelChordPad
	//# Set chrd_to_label var before calling xlcp
	chord_slot = (current_scene * 100) + ((chrd_to_label-8) * 10)
	//# txpose amount. get value stored on dial use to access array of st amounts
	txpose_index = scene_bank[(current_scene * sc_size) + sc_txp_slot]
	sta = txpose_array[txpose_index] //# scene txpose amount
	cn1 = (chord_bank[chord_slot] + 12 + sta) % 12
	cn2 = (chord_bank[chord_slot + 1] + 12 + sta) % 12
	cn3 = (chord_bank[chord_slot + 2] + 12 + sta) % 12
	if chord_bank[chord_slot + 3] >= 0
		cn4 = (chord_bank[chord_slot + 3] + 12 + sta) % 12
	else
		cn4 = chord_bank[chord_slot + 3] // ie -1 no 7th note
	endif
	cd = chord_bank[chord_slot + dur_slot]
	cd_bars = Div cd, 4
	lc_beats = (cd % HostBeatsPerMeasure) * (100/HostBeatsPerMeasure)
	ci = chord_bank[chord_slot + inv_slot]
	Call @ReorderNoteLabelsForInversion
	if cn4 >= 0 //# A tetrad witha a note i cn4 
		LabelPad chrd_to_label, {[}, cd_bars, {.}, lc_beats, { bars]}, { Inv:}, 	ci, {     Root:}, (NoteName cn1), {      }, (NoteName invo[0]), (NoteName invo[1]), (NoteName invo[2]), (NoteName invo[3])  
	else
		LabelPad chrd_to_label, {[}, cd_bars, {.}, lc_beats, { bars]}, { Inv:}, 	ci, {     Root:}, (NoteName cn1), {      }, (NoteName invo[0]), (NoteName invo[1]), (NoteName invo[2])
	endif
@End

@ReorderNoteLabelsForInversion
	//# Just re-orders the notes on the chord pad in inverted order
	invo = [] //# inverted chord notes
	if (ci = 0) or (ci = 4) or (ci = -4)
		invo = [cn1, cn2, cn3, cn4]
	elseif ci = 1
		invo = [cn2, cn3, cn4, cn1]
		if cn4 = -1
			invo = [cn2, cn3, cn1, cn4]
		endif
	elseif ci = 2
		invo = [cn3, cn4, cn1, cn2]
		if cn4 = -1
			invo = [cn3, cn1, cn2, cn4]
		endif
	elseif ci = 3
		invo = [cn4, cn1, cn2, cn3]
		if cn4 = -1
			invo = [cn1, cn2, cn3, cn4]
		endif
	elseif ci = -1
		invo = [cn4, cn1, cn2, cn3]
		if cn4 = -1
			invo = [cn3, cn1, cn2, cn4]
		endif
	elseif ci = -2
		invo = [cn3, cn4, cn1, cn2]
		if cn4 = -1
			invo = [cn2, cn3, cn1, cn4]
		endif
	elseif ci = -3
		invo = [cn2, cn3, cn4, cn1]
		if cn4 = -1
			invo = [cn1, cn2, cn3, cn4]
		endif
	endif
@End

@SetupLayout
	//#setup layout pads
    if in_settings_mode
        Exit
    elseif mode=9
        Call @SetUpHarmonyKeyboard
        Call @SetupKnobset5
    else
		//# Setup scene pads
		FillArray scn_pad_cols, 0, 16
		for i = 0 to 7  
            if scene_bank[i * sc_size] > 0
                    scn_pad_cols[i]=2
                    scn_to_label = i
                    Call @LabelScenePad
            else
                    scn_pad_cols[i]=0
                LabelPad i, { }
            endif
            LatchPad i, NO
            if (scene_bank[i * sc_size] > 0) and (mode=7) and NOT in_settings_mode
                    scn_pad_cols[i]=1
            endif
	    endfor		  
	    //# Setup chord pads  
        for i = 8 to 15
            chord_slot = (current_scene * 100) + ((i-8) * 10)
            LatchPad i, NO
            if chord_bank[chord_slot + dur_slot] > 0
                    scn_pad_cols[i]=2
                chrd_to_label = i
                Call @LabelChordPad
            else 
                    scn_pad_cols[i]=0
                LabelPad i, { }
            endif
            if (mode = 3) //del
                    scn_pad_cols[i]=1
            elseif (mode=7) and (chord_bank[chord_slot] >= 0)
                    scn_pad_cols[i]=1
            endif
        endfor
            //# Handle current scene and chord colors
        if (songmode = 0) //# Playthru no lock
            scn_pad_cols[current_scene]=3
            scn_pad_cols[current_chord+8]=3
        elseif (songmode = 1) //# Lock to scene
            scn_pad_cols[current_chord+8]=3
                scn_pad_cols[current_scene]=4
        elseif (songmode = 2)
            scn_pad_cols[current_chord+8]=4
                scn_pad_cols[current_scene]=4
        elseif (mode = 3) //# REC CHORDS 
                scn_pad_cols[current_chord+8]=1
                if rec_chord_note_count = 0
                    LabelPad current_chord+8, {... waiting}
                endif
            endif
            //# Handle pending chord and scene changes in playback
        if HostRunning and (songmode <=2)
            if chord_change_requested >= 0
                    scn_pad_cols[chord_change_requested+8]=6
            endif
            if scene_change_requested >= 0
                scn_pad_cols[scene_change_requested]=6
            endif
        endif
        for i = 0 to 15
		    ColorPad i, scn_pad_cols[i]
	    endfor
    endif
@End
	
@TransposeCalcArrays
	if txpose_w_circle_fifths
	  //# Creates an array to transpose using the circle of 5ths 
	  //# but keeping to one octave
	  FillArray txpose_array, 99, 13
	  FillArray txpose_labels, 99, 13 
	  txpose_index = 0
	  for i = 6 to 11
	    key = (i * 7) % 12
	    txpose_val = key
	    if key > Abs (key - 12)
	      txpose_val = key - 12 
	    endif
	    // Log {APos: }, i, { Key: }, (NoteName key), { TXPOSE: }, txpose_val, { Semitones: }, key, { -VE: }, key -12
	    txpose_array[txpose_index] = txpose_val
	    label = txpose_array[txpose_index]
	    if txpose_array[txpose_index] < 0
	      label = txpose_array[txpose_index] + 12
	    endif
	    txpose_labels[txpose_index] = label
	    txpose_index = txpose_index + 1 
	  endfor  
	  for i = 0 to 6
	    key = (i * 7) % 12
	    txpose_val = key
	    if key > Abs (key - 12)
	      txpose_val = key - 12 
	    endif
	    // Log {BPos: }, i, { Key: }, (NoteName key), { TXPOSE: }, txpose_val, { Semitones: }, key, { -VE: }, key -12 
	    txpose_array[txpose_index] = txpose_val
	    label = txpose_array[txpose_index]
	    if txpose_array[txpose_index] < 0
	      label = txpose_array[txpose_index] + 12
	    endif
	    txpose_labels[txpose_index] = label
	    txpose_index = txpose_index + 1
	  endfor
	else
		txpose_array = [-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6]
	endif
@End

@ChangeScenePreset
	//# Update chords for the current scene with a set of chords
	//# Create a scene in scene_bank
	//# use arrays psd, psn, prog_durs, prog_invs, prog_bass to load data 
	//# use psn array for scale notes, use 0 in front to keep numbering sane
	//# use 1 octave of scale notes. Inversions will be calculated
	//# Call @HandleChordBankPresetUpdate and then LabelPads with scene name
	//# ionian = [2,2,1,2,2,2,1] CDEFGABC [0, 60, 62, 64, 65, 67, 69, 71, 72]
	//# dorian = [2,1,2,2,2,1,2] DEFGABCD [0, 62, 64, 65, 67, 69, 71, 72, 74]
 	//# phrygian = [1,2,2,2,1,2,2] EFGABCDE [0, 64, 65, 67, 69, 71, 72, 74, 76]
	//# lydian = [2,2,2,1,2,2,1] FGABCDEF [0, 65, 67, 69, 71, 72, 74, 76, 77]
	//# mixolydian = [2,2,1,2,2,1,2] GABCDEFG [0, 67, 69, 71, 72, 74, 76, 77, 79]
	//# aeolian = [2,1,2,2,1,2,2,] ABCDEFGA [0, 69, 71, 72, 74, 76, 77, 79, 81]
	//# locrian = [1,2,2,1,2,2,2] BCDEFGAB [0, 71, 72, 74, 76, 77, 79, 81, 83]
	
	//# Default chord bank settings. Copy to preset to override
	//# scene setup. map txpose based on circle of 5ths. 
	//# scn_preset must always be setting for preset (self)
	scn_dur = scene_bank[current_scene * sc_size]
	scn_dur=16
	scene_bank[current_scene * sc_size] = [scn_dur,6,scn_preset,1,1,1,1,8,8,8,8,-1]
	
	//# chord settings
	//# psd is scale degrees for each chord in the progression
	psd = [1,3,5,-1, 2,4,6,-1, 3,5,7,-1, 4,6,1,-1, 5,7,2,-1, 6,1,3,-1, 7,2,4,-1, 1,3,5,7]
	//# other settings for the 8 chord slots in this current scene
	prog_durs = [4,4,4,4,4,4,4,4]
	prog_bass = [1,2,3,4,5,6,7,1]
	prog_invs = [0,0,0,0,0,0,0,3]
	//# chord notes always stored in an ascending order. 
	//# So 461 will have an octave added to the 1. 
	//# prog_invs are applied at NoteOut. No effect on how notes stored here
				
	if scn_preset = 1
  	    scene_bank[current_scene * sc_size] = [scn_dur,6,scn_preset,1,1,1,1,8,8,8,8,-1]
        chord_bank[(current_scene * 100) + 0]  = [-1,-1,-1,-1,0,0,-1]
        chord_bank[(current_scene * 100) + 10] = [-1,-1,-1,-1,0,0,-1]
        chord_bank[(current_scene * 100) + 20] = [-1,-1,-1,-1,0,0,-1]
        chord_bank[(current_scene * 100) + 30] = [-1,-1,-1,-1,0,0,-1]
        chord_bank[(current_scene * 100) + 40] = [-1,-1,-1,-1,0,0,-1]
        chord_bank[(current_scene * 100) + 50] = [-1,-1,-1,-1,0,0,-1]
        chord_bank[(current_scene * 100) + 60] = [-1,-1,-1,-1,0,0,-1]
        chord_bank[(current_scene * 100) + 70] = [-1,-1,-1,-1,0,0,-1]
        LabelPads {An empty scene. Press shift to select a +CHORDS mode}
        Call @SetupLayout
	elseif scn_preset = 2
		scene_bank[current_scene * sc_size] = [scn_dur,6,scn_preset,1,1,1,1,8,8,8,8,-1]
		psn = [0, 60, 62, 64, 65, 67, 69, 71, 72]
		psd = [1,3,5,-1, 5,7,2,-1, 6,1,3,-1, 4,6,1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1]
		prog_durs = [4,4,4,4,0,0,0,0]
		prog_bass = [1,5,6,4,0,0,0,0]
		prog_invs = [0,-1,-1,-1,0,0,0,0]
		Call @HandleChordBankPresetUpdate
		chord_bank[(current_scene * 100) + 40] = [-1,-1,-1,-1,0,0,-1] //overwrite with empty
        chord_bank[(current_scene * 100) + 50] = [-1,-1,-1,-1,0,0,-1]
        chord_bank[(current_scene * 100) + 60] = [-1,-1,-1,-1,0,0,-1]
        chord_bank[(current_scene * 100) + 70] = [-1,-1,-1,-1,0,0,-1]
        LabelPads {Classic I-V-vi-IV progression in C Major}
	elseif scn_preset = 3
		psn = [0, 60, 62, 64, 65, 67, 69, 71, 72]
		prog_invs = [0,0,0,0,0,0,0,4]
		Call @HandleChordBankPresetUpdate
  	LabelPads {C IONIAN Major diatonic chord set}
	elseif scn_preset = 4
		psn = [0, 62, 64, 65, 67, 69, 71, 72, 74]
		prog_invs = [0,0,0,0,0,0,3,4]
		Call @HandleChordBankPresetUpdate
  	LabelPads {D DORIAN diatonic chord set}
  elseif scn_preset = 5
		psn = [0, 64, 65, 67, 69, 71, 72, 74, 76]
		prog_invs = [0,0,0,0,0,3,3,4]
		Call @HandleChordBankPresetUpdate
  	LabelPads {E PHRYGIAN diatonic chord set}
  elseif scn_preset = 6
		psn = [0, 65, 67, 69, 71, 72, 74, 76, 77]
		prog_invs = [0,0,0,0,3,3,3,4]
		Call @HandleChordBankPresetUpdate
  	LabelPads {F LYDIAN diatonic chord set}
  elseif scn_preset = 7
		psn = [0, 67, 69, 71, 72, 74, 76, 77, 79]
		prog_invs = [0,0,0,3,3,3,3,4]
		Call @HandleChordBankPresetUpdate
  	LabelPads {G MIXOLYDIAN diatonic chord set}
  elseif scn_preset = 8
		psn = [0, 69, 71, 72, 74, 76, 77, 79, 81]
		prog_invs = [0,0,3,3,3,3,3,4]
		Call @HandleChordBankPresetUpdate
  	LabelPads {A AEOLIAN Natural Minor diatonic chord set}
  elseif scn_preset = 9
		psn = [0, 71, 72, 74, 76, 77, 79, 81, 83]
		prog_invs = [0,3,3,3,3,3,3,4]
		Call @HandleChordBankPresetUpdate
  	LabelPads {B LOCRIAN diatonic chord set}
  elseif scn_preset = 10
	  scene_bank[current_scene * sc_size] = [scn_dur,6,10,1,1,1,1,8,8,8,8,-1]
	  chord_bank[(current_scene * 100) + 0] = [9,12,16,-1,4,0,69]
	  chord_bank[(current_scene * 100) + 10] = [11,14,17,-1,4,0,71]
	  chord_bank[(current_scene * 100) + 20] = [0,4,7,-1,4,3,72]
	  chord_bank[(current_scene * 100) + 30] = [2,5,9,-1,4,3,74]
	  chord_bank[(current_scene * 100) + 40] = [4,8,11,-1,4,3,76]
	  chord_bank[(current_scene * 100) + 50] = [5,9,12,-1,4,3,77]
	  chord_bank[(current_scene * 100) + 60] = [7,10,13,-1,4,3,7]
	  chord_bank[(current_scene * 100) + 70] = [9,12,16,-1,4,3,69]
	  LabelPads {Minor triadic harmony (from Natural & Harmonic minor diatonic chords)} 
 	  Call @SetupLayout
	elseif scn_preset = 11
	  scene_bank[current_scene * sc_size] = [scn_dur,6,10,1,1,1,1,8,8,8,8,-1]
	  chord_bank[(current_scene * 100) + 0] = [9,12,16,19,4,0,69]
	  chord_bank[(current_scene * 100) + 10] = [11,14,17,21,4,0,71]
	  chord_bank[(current_scene * 100) + 20] = [0,4,7,11,4,4,72]
	  chord_bank[(current_scene * 100) + 30] = [2,5,9,12,4,4,74]
	  chord_bank[(current_scene * 100) + 40] = [4,8,11,14,4,4,76]
	  chord_bank[(current_scene * 100) + 50] = [5,9,12,16,4,4,77]
	  chord_bank[(current_scene * 100) + 60] = [7,10,13,17,4,4,7]
	  chord_bank[(current_scene * 100) + 70] = [9,12,16,19,4,4,69]
	  LabelPads {Diatonic 7th chords Minor (Hybrid)} 
	  Call @SetupLayout
  elseif scn_preset = 12
    scene_bank[current_scene * sc_size] = [scn_dur,6,13,1,1,1,1,8,8,8,8,-1]
    chord_bank[(current_scene * 100) + 0] = [0,4,7,-1,4,0,0]
    chord_bank[(current_scene * 100) + 10] = [0,4,7,-1,4,-1,0]
    chord_bank[(current_scene * 100) + 20] = [0,4,7,-1,4,1,0]
    chord_bank[(current_scene * 100) + 30] = [0,3,7,-1,4,0,0]
    chord_bank[(current_scene * 100) + 40] = [0,2,7,-1,4,0,0]
    chord_bank[(current_scene * 100) + 50] = [0,5,7,-1,4,0,0]
    chord_bank[(current_scene * 100) + 60] = [0,4,7,11,4,0,0]
    chord_bank[(current_scene * 100) + 70] = [0,4,7,10,4,0,0]
 		LabelPads {Noodling the tonic - MAJOR} 
 		Call @SetupLayout
  elseif scn_preset = 13
    scene_bank[current_scene * sc_size] = [scn_dur,6,13,1,1,1,1,8,8,8,8,-1]
    chord_bank[(current_scene * 100) + 0] = [9,12,16,-1,4,0,9]
    chord_bank[(current_scene * 100) + 10] = [9,12,16,-1,4,-1,9]
    chord_bank[(current_scene * 100) + 20] = [9,12,16,-1,4,1,9]
    chord_bank[(current_scene * 100) + 30] = [9,11,16,-1,4,0,9]
    chord_bank[(current_scene * 100) + 40] = [9,14,16,-1,4,0,9]
    chord_bank[(current_scene * 100) + 50] = [9,12,16,-1,4,0,9]
    chord_bank[(current_scene * 100) + 60] = [9,12,16,19,4,0,9]
    chord_bank[(current_scene * 100) + 70] = [9,13,16,19,4,0,9]
 		LabelPads {Noodling the tonic - MINOR} 
 		Call @SetupLayout
  endif
	Call @MakeChordScaleForScene
@End

@HandleChordBankPresetUpdate
	chord_slot = (current_scene * 100)
	for c = 0 to 7
		//# get from scale note array using scale degree as index
		cn1 = psn[ psd[(c*4) + 0] ]
		cn2 = psn[ psd[(c*4) + 1] ]
		cn3 = psn[ psd[(c*4) + 2] ]
		//# Log {CNs }, cn1, cn2, cn3
		if psd[(c*4) + 3] >= 0 //# 7th note is added
			cn4 = psn[ psd[(c*4) + 3] ]
		else
			cn4 = -1
		endif
		//# return scale degrees to root inversion
		if cn2 < cn1
			cn2 = cn2 + 12
			//# Log {cn2 after inv: }, cn2
		endif
		if cn3 < cn2
			cn3 = cn3 + 12
			//# Log {cn3 after inv: }, cn3
		endif
		if (cn4 >= 0) and (cn4 < cn3)
			cn4 = cn4 + 12
			//# Log {cn4 after inv: }, cn4
		endif
		chord_bank[chord_slot + (c*10) + 0] = cn1
		chord_bank[chord_slot + (c*10) + 1] = cn2
		chord_bank[chord_slot + (c*10) + 2] = cn3
		chord_bank[chord_slot + (c*10) + 3] = cn4
		chord_bank[chord_slot + (c*10) + 4] = prog_durs[c]
		chord_bank[chord_slot + (c*10) + 5] = prog_invs[c]
		chord_bank[chord_slot + (c*10) + 6] = psn[ prog_bass[c] ]
	endfor
	Call @SetupLayout
@End

@LogCurrentSceneToPresetFormat
	//# Logs current scene to a format which can be added to the preset section
	Log {======= END PRESET LOG =======}
	Log {	 Call @SetupLayout}
	Log {	 LabelPads YOUR PRESET NAME -in curly brackets!! } 
	chord_slot = (current_scene * 100)
	for c = 7 to 0
		c_loc = (chord_slot + (c*10))
		n1 = chord_bank[c_loc]
		n2 = chord_bank[c_loc + 1]
		n3 = chord_bank[c_loc + 2]
		n4 = chord_bank[c_loc + 3]
		d = chord_bank[c_loc + dur_slot]
		i = chord_bank[c_loc + inv_slot]
		Log {	   chord_bank[(current_scene * 100) + }, c*10, {] = [}, n1,{,}, n2,{,}, n3,{,}, n4,{,}, d,{,}, i, {]}
	endfor
	Log {	   scene_bank[},{current_scene * sc_size}, {] = [4,6,}, num_sc_presets+1, {,0,0,0,0,0,0,0,0,-1]}
	Log {elseif scn_preset = }, num_sc_presets+1
	Log {======= START PRESET LOG =======}
	Log {+ Make sure to change YOUR PRESET NAME and put it in curly brackets}
	Log {+ Update num_sc_presets variable to }, num_sc_presets+1,{ in @InitKnobVariables}
	Log {+ Copy this PRESET LOG to the end of @ChangeScenePreset before 'endif'}
	Log {++++++ INSTRUCTIONS FOR ADDING A PRESET +++++}
@End
